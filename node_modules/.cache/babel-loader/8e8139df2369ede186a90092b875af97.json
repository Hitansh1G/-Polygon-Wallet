{"ast":null,"code":"(function () {\n  /*\n  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n  Code distributed by Google as part of the polymer project is also\n  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n  */\n  'use strict';\n\n  var n;\n\n  function aa(a) {\n    var b = 0;\n    return function () {\n      return b < a.length ? {\n        done: !1,\n        value: a[b++]\n      } : {\n        done: !0\n      };\n    };\n  }\n\n  function ba(a) {\n    var b = \"undefined\" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];\n    return b ? b.call(a) : {\n      next: aa(a)\n    };\n  }\n\n  function p(a) {\n    if (!(a instanceof Array)) {\n      a = ba(a);\n\n      for (var b, c = []; !(b = a.next()).done;) c.push(b.value);\n\n      a = c;\n    }\n\n    return a;\n  }\n\n  function ca(a) {\n    a = [\"object\" == typeof globalThis && globalThis, a, \"object\" == typeof window && window, \"object\" == typeof self && self, \"object\" == typeof global && global];\n\n    for (var b = 0; b < a.length; ++b) {\n      var c = a[b];\n      if (c && c.Math == Math) return c;\n    }\n\n    throw Error(\"Cannot find global object\");\n  }\n\n  var da = ca(this);\n\n  function ea() {}\n\n  ea.prototype.toJSON = function () {\n    return {};\n  };\n\n  function q(a) {\n    a.__shady || (a.__shady = new ea());\n    return a.__shady;\n  }\n\n  function t(a) {\n    return a && a.__shady;\n  }\n\n  ;\n  var u = window.ShadyDOM || {};\n  u.Y = !(!Element.prototype.attachShadow || !Node.prototype.getRootNode);\n  var fa = Object.getOwnPropertyDescriptor(Node.prototype, \"firstChild\");\n  u.i = !!(fa && fa.configurable && fa.get);\n  u.K = u.force || !u.Y;\n  u.l = u.noPatch || !1;\n  u.A = u.preferPerformance;\n  u.L = \"on-demand\" === u.l;\n  u.R = navigator.userAgent.match(\"Trident\");\n\n  function ha() {\n    return Document.prototype.msElementsFromPoint ? \"msElementsFromPoint\" : \"elementsFromPoint\";\n  }\n\n  function v(a) {\n    return (a = t(a)) && void 0 !== a.firstChild;\n  }\n\n  function w(a) {\n    return a instanceof ShadowRoot;\n  }\n\n  function ia(a) {\n    return (a = (a = t(a)) && a.root) && ja(a);\n  }\n\n  var x = Element.prototype,\n      ka = x.matches || x.matchesSelector || x.mozMatchesSelector || x.msMatchesSelector || x.oMatchesSelector || x.webkitMatchesSelector,\n      la = document.createTextNode(\"\"),\n      ma = 0,\n      na = [];\n  new MutationObserver(function () {\n    for (; na.length;) try {\n      na.shift()();\n    } catch (a) {\n      throw la.textContent = ma++, a;\n    }\n  }).observe(la, {\n    characterData: !0\n  });\n\n  function oa(a) {\n    na.push(a);\n    la.textContent = ma++;\n  }\n\n  var pa = document.contains ? function (a, b) {\n    return a.__shady_native_contains(b);\n  } : function (a, b) {\n    return a === b || a.documentElement && a.documentElement.__shady_native_contains(b);\n  };\n\n  function qa(a, b) {\n    for (; b;) {\n      if (b == a) return !0;\n      b = b.__shady_parentNode;\n    }\n\n    return !1;\n  }\n\n  function y(a) {\n    for (var b = a.length - 1; 0 <= b; b--) {\n      var c = a[b],\n          d = c.getAttribute(\"id\") || c.getAttribute(\"name\");\n      d && \"length\" !== d && isNaN(d) && (a[d] = c);\n    }\n\n    a.item = function (e) {\n      return a[e];\n    };\n\n    a.namedItem = function (e) {\n      if (\"length\" !== e && isNaN(e) && a[e]) return a[e];\n\n      for (var f = ba(a), g = f.next(); !g.done; g = f.next()) if (g = g.value, (g.getAttribute(\"id\") || g.getAttribute(\"name\")) == e) return g;\n\n      return null;\n    };\n\n    return a;\n  }\n\n  function ra(a) {\n    var b = [];\n\n    for (a = a.__shady_native_firstChild; a; a = a.__shady_native_nextSibling) b.push(a);\n\n    return b;\n  }\n\n  function sa(a) {\n    var b = [];\n\n    for (a = a.__shady_firstChild; a; a = a.__shady_nextSibling) b.push(a);\n\n    return b;\n  }\n\n  function ta(a, b, c) {\n    c.configurable = !0;\n    if (c.value) a[b] = c.value;else try {\n      Object.defineProperty(a, b, c);\n    } catch (d) {}\n  }\n\n  function z(a, b, c, d) {\n    c = void 0 === c ? \"\" : c;\n\n    for (var e in b) d && 0 <= d.indexOf(e) || ta(a, c + e, b[e]);\n  }\n\n  function ua(a, b) {\n    for (var c in b) c in a && ta(a, c, b[c]);\n  }\n\n  function A(a) {\n    var b = {};\n    Object.getOwnPropertyNames(a).forEach(function (c) {\n      b[c] = Object.getOwnPropertyDescriptor(a, c);\n    });\n    return b;\n  }\n\n  function va(a, b) {\n    for (var c = Object.getOwnPropertyNames(b), d = 0, e; d < c.length; d++) e = c[d], a[e] = b[e];\n  }\n\n  function wa(a) {\n    return a instanceof Node ? a : document.createTextNode(\"\" + a);\n  }\n\n  function B(a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    if (1 === b.length) return wa(b[0]);\n    c = document.createDocumentFragment();\n    b = ba(b);\n\n    for (var d = b.next(); !d.done; d = b.next()) c.appendChild(wa(d.value));\n\n    return c;\n  }\n\n  ;\n  var D = [],\n      xa;\n\n  function ya(a) {\n    xa || (xa = !0, oa(E));\n    D.push(a);\n  }\n\n  function E() {\n    xa = !1;\n\n    for (var a = !!D.length; D.length;) D.shift()();\n\n    return a;\n  }\n\n  E.list = D;\n\n  function za() {\n    this.g = !1;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.F = new Set();\n  }\n\n  function Aa(a) {\n    a.g || (a.g = !0, oa(function () {\n      a.flush();\n    }));\n  }\n\n  za.prototype.flush = function () {\n    if (this.g) {\n      this.g = !1;\n      var a = this.takeRecords();\n      a.length && this.F.forEach(function (b) {\n        b(a);\n      });\n    }\n  };\n\n  za.prototype.takeRecords = function () {\n    if (this.addedNodes.length || this.removedNodes.length) {\n      var a = [{\n        addedNodes: this.addedNodes,\n        removedNodes: this.removedNodes\n      }];\n      this.addedNodes = [];\n      this.removedNodes = [];\n      return a;\n    }\n\n    return [];\n  };\n\n  function Ba(a, b) {\n    var c = q(a);\n    c.v || (c.v = new za());\n    c.v.F.add(b);\n    var d = c.v;\n    return {\n      V: b,\n      X: d,\n      W: a,\n      takeRecords: function () {\n        return d.takeRecords();\n      }\n    };\n  }\n\n  function Ca(a) {\n    var b = a && a.X;\n    b && (b.F.delete(a.V), b.F.size || (q(a.W).v = null));\n  }\n\n  function Da(a, b) {\n    var c = b.getRootNode();\n    return a.map(function (d) {\n      var e = c === d.target.getRootNode();\n\n      if (e && d.addedNodes) {\n        if (e = [].slice.call(d.addedNodes).filter(function (f) {\n          return c === f.getRootNode();\n        }), e.length) return d = Object.create(d), Object.defineProperty(d, \"addedNodes\", {\n          value: e,\n          configurable: !0\n        }), d;\n      } else if (e) return d;\n    }).filter(function (d) {\n      return d;\n    });\n  }\n\n  ;\n  var Ea = /[&\\u00A0\"]/g,\n      Fa = /[&\\u00A0<>]/g;\n\n  function Ga(a) {\n    switch (a) {\n      case \"&\":\n        return \"&amp;\";\n\n      case \"<\":\n        return \"&lt;\";\n\n      case \">\":\n        return \"&gt;\";\n\n      case '\"':\n        return \"&quot;\";\n\n      case \"\\u00a0\":\n        return \"&nbsp;\";\n    }\n  }\n\n  function Ha(a) {\n    for (var b = {}, c = 0; c < a.length; c++) b[a[c]] = !0;\n\n    return b;\n  }\n\n  var Ia = Ha(\"area base br col command embed hr img input keygen link meta param source track wbr\".split(\" \")),\n      Ja = Ha(\"style script xmp iframe noembed noframes plaintext noscript\".split(\" \"));\n\n  function Ka(a, b) {\n    \"template\" === a.localName && (a = a.content);\n\n    for (var c = \"\", d = b ? b(a) : a.childNodes, e = 0, f = d.length, g = void 0; e < f && (g = d[e]); e++) {\n      a: {\n        var h = g;\n        var m = a,\n            l = b;\n\n        switch (h.nodeType) {\n          case Node.ELEMENT_NODE:\n            m = h.localName;\n\n            for (var k = \"<\" + m, r = h.attributes, C = 0, P; P = r[C]; C++) k += \" \" + P.name + '=\"' + P.value.replace(Ea, Ga) + '\"';\n\n            k += \">\";\n            h = Ia[m] ? k : k + Ka(h, l) + \"</\" + m + \">\";\n            break a;\n\n          case Node.TEXT_NODE:\n            h = h.data;\n            h = m && Ja[m.localName] ? h : h.replace(Fa, Ga);\n            break a;\n\n          case Node.COMMENT_NODE:\n            h = \"\\x3c!--\" + h.data + \"--\\x3e\";\n            break a;\n\n          default:\n            throw window.console.error(h), Error(\"not implemented\");\n        }\n      }\n\n      c += h;\n    }\n\n    return c;\n  }\n\n  ;\n  var F = u.i,\n      La = {\n    querySelector: function (a) {\n      return this.__shady_native_querySelector(a);\n    },\n    querySelectorAll: function (a) {\n      return this.__shady_native_querySelectorAll(a);\n    }\n  },\n      Ma = {};\n\n  function Na(a) {\n    Ma[a] = function (b) {\n      return b[\"__shady_native_\" + a];\n    };\n  }\n\n  function G(a, b) {\n    z(a, b, \"__shady_native_\");\n\n    for (var c in b) Na(c);\n  }\n\n  function H(a, b) {\n    b = void 0 === b ? [] : b;\n\n    for (var c = 0; c < b.length; c++) {\n      var d = b[c],\n          e = Object.getOwnPropertyDescriptor(a, d);\n      e && (Object.defineProperty(a, \"__shady_native_\" + d, e), e.value ? La[d] || (La[d] = e.value) : Na(d));\n    }\n  }\n\n  var I = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, !1),\n      J = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, !1),\n      Oa = document.implementation.createHTMLDocument(\"inert\");\n\n  function Pa(a) {\n    for (var b; b = a.__shady_native_firstChild;) a.__shady_native_removeChild(b);\n  }\n\n  var Qa = [\"firstElementChild\", \"lastElementChild\", \"children\", \"childElementCount\"],\n      Ra = [\"querySelector\", \"querySelectorAll\", \"append\", \"prepend\", \"replaceChildren\"];\n\n  function Sa() {\n    var a = [\"dispatchEvent\", \"addEventListener\", \"removeEventListener\"];\n    window.EventTarget ? (H(window.EventTarget.prototype, a), void 0 === window.__shady_native_addEventListener && H(Window.prototype, a)) : (H(Node.prototype, a), H(Window.prototype, a));\n    F ? H(Node.prototype, \"parentNode firstChild lastChild previousSibling nextSibling childNodes parentElement textContent\".split(\" \")) : G(Node.prototype, {\n      parentNode: {\n        get: function () {\n          I.currentNode = this;\n          return I.parentNode();\n        }\n      },\n      firstChild: {\n        get: function () {\n          I.currentNode = this;\n          return I.firstChild();\n        }\n      },\n      lastChild: {\n        get: function () {\n          I.currentNode = this;\n          return I.lastChild();\n        }\n      },\n      previousSibling: {\n        get: function () {\n          I.currentNode = this;\n          return I.previousSibling();\n        }\n      },\n      nextSibling: {\n        get: function () {\n          I.currentNode = this;\n          return I.nextSibling();\n        }\n      },\n      childNodes: {\n        get: function () {\n          var b = [];\n          I.currentNode = this;\n\n          for (var c = I.firstChild(); c;) b.push(c), c = I.nextSibling();\n\n          return b;\n        }\n      },\n      parentElement: {\n        get: function () {\n          J.currentNode = this;\n          return J.parentNode();\n        }\n      },\n      textContent: {\n        get: function () {\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              for (var b = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, !1), c = \"\", d; d = b.nextNode();) c += d.nodeValue;\n\n              return c;\n\n            default:\n              return this.nodeValue;\n          }\n        },\n        set: function (b) {\n          if (\"undefined\" === typeof b || null === b) b = \"\";\n\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              Pa(this);\n              (0 < b.length || this.nodeType === Node.ELEMENT_NODE) && this.__shady_native_insertBefore(document.createTextNode(b), void 0);\n              break;\n\n            default:\n              this.nodeValue = b;\n          }\n        }\n      }\n    });\n    H(Node.prototype, \"appendChild insertBefore removeChild replaceChild cloneNode contains\".split(\" \"));\n    H(HTMLElement.prototype, [\"parentElement\", \"contains\"]);\n    a = {\n      firstElementChild: {\n        get: function () {\n          J.currentNode = this;\n          return J.firstChild();\n        }\n      },\n      lastElementChild: {\n        get: function () {\n          J.currentNode = this;\n          return J.lastChild();\n        }\n      },\n      children: {\n        get: function () {\n          var b = [];\n          J.currentNode = this;\n\n          for (var c = J.firstChild(); c;) b.push(c), c = J.nextSibling();\n\n          return y(b);\n        }\n      },\n      childElementCount: {\n        get: function () {\n          return this.children ? this.children.length : 0;\n        }\n      }\n    };\n    F ? (H(Element.prototype, Qa), H(Element.prototype, [\"previousElementSibling\", \"nextElementSibling\", \"innerHTML\", \"className\"]), H(HTMLElement.prototype, [\"children\", \"innerHTML\", \"className\"])) : (G(Element.prototype, a), G(Element.prototype, {\n      previousElementSibling: {\n        get: function () {\n          J.currentNode = this;\n          return J.previousSibling();\n        }\n      },\n      nextElementSibling: {\n        get: function () {\n          J.currentNode = this;\n          return J.nextSibling();\n        }\n      },\n      innerHTML: {\n        get: function () {\n          return Ka(this, ra);\n        },\n        set: function (b) {\n          var c = \"template\" === this.localName ? this.content : this;\n          Pa(c);\n          var d = this.localName || \"div\";\n          d = this.namespaceURI && this.namespaceURI !== Oa.namespaceURI ? Oa.createElementNS(this.namespaceURI, d) : Oa.createElement(d);\n          d.innerHTML = b;\n\n          for (b = \"template\" === this.localName ? d.content : d; d = b.__shady_native_firstChild;) c.__shady_native_insertBefore(d, void 0);\n        }\n      },\n      className: {\n        get: function () {\n          return this.getAttribute(\"class\") || \"\";\n        },\n        set: function (b) {\n          this.setAttribute(\"class\", b);\n        }\n      }\n    }));\n    H(Element.prototype, \"setAttribute getAttribute hasAttribute removeAttribute focus blur\".split(\" \"));\n    H(Element.prototype, Ra);\n    H(HTMLElement.prototype, [\"focus\", \"blur\"]);\n    window.HTMLTemplateElement && H(window.HTMLTemplateElement.prototype, [\"innerHTML\"]);\n    F ? H(DocumentFragment.prototype, Qa) : G(DocumentFragment.prototype, a);\n    H(DocumentFragment.prototype, Ra);\n    F ? (H(Document.prototype, Qa), H(Document.prototype, [\"activeElement\"])) : G(Document.prototype, a);\n    H(Document.prototype, [\"importNode\", \"getElementById\", \"elementFromPoint\", ha()]);\n    H(Document.prototype, Ra);\n  }\n\n  ;\n  var Ta = A({\n    get childNodes() {\n      return this.__shady_childNodes;\n    },\n\n    get firstChild() {\n      return this.__shady_firstChild;\n    },\n\n    get lastChild() {\n      return this.__shady_lastChild;\n    },\n\n    get childElementCount() {\n      return this.__shady_childElementCount;\n    },\n\n    get children() {\n      return this.__shady_children;\n    },\n\n    get firstElementChild() {\n      return this.__shady_firstElementChild;\n    },\n\n    get lastElementChild() {\n      return this.__shady_lastElementChild;\n    },\n\n    get shadowRoot() {\n      return this.__shady_shadowRoot;\n    }\n\n  }),\n      Ua = A({\n    get textContent() {\n      return this.__shady_textContent;\n    },\n\n    set textContent(a) {\n      this.__shady_textContent = a;\n    },\n\n    get innerHTML() {\n      return this.__shady_innerHTML;\n    },\n\n    set innerHTML(a) {\n      this.__shady_innerHTML = a;\n    }\n\n  }),\n      Va = A({\n    get parentElement() {\n      return this.__shady_parentElement;\n    },\n\n    get parentNode() {\n      return this.__shady_parentNode;\n    },\n\n    get nextSibling() {\n      return this.__shady_nextSibling;\n    },\n\n    get previousSibling() {\n      return this.__shady_previousSibling;\n    },\n\n    get nextElementSibling() {\n      return this.__shady_nextElementSibling;\n    },\n\n    get previousElementSibling() {\n      return this.__shady_previousElementSibling;\n    },\n\n    get className() {\n      return this.__shady_className;\n    },\n\n    set className(a) {\n      this.__shady_className = a;\n    }\n\n  });\n\n  function Wa(a) {\n    for (var b in a) {\n      var c = a[b];\n      c && (c.enumerable = !1);\n    }\n  }\n\n  Wa(Ta);\n  Wa(Ua);\n  Wa(Va);\n  var Xa = u.i || !0 === u.l,\n      Ya = Xa ? function () {} : function (a) {\n    var b = q(a);\n    b.T || (b.T = !0, ua(a, Va));\n  },\n      Za = Xa ? function () {} : function (a) {\n    var b = q(a);\n    b.S || (b.S = !0, ua(a, Ta), window.customElements && window.customElements.polyfillWrapFlushCallback && !u.l || ua(a, Ua));\n  };\n\n  var K = \"__eventWrappers\" + Date.now(),\n      $a = function () {\n    var a = Object.getOwnPropertyDescriptor(Event.prototype, \"composed\");\n    return a ? function (b) {\n      return a.get.call(b);\n    } : null;\n  }(),\n      ab = function () {\n    function a() {}\n\n    var b = !1,\n        c = {\n      get capture() {\n        b = !0;\n        return !1;\n      }\n\n    };\n    window.addEventListener(\"test\", a, c);\n    window.removeEventListener(\"test\", a, c);\n    return b;\n  }();\n\n  function bb(a) {\n    if (a && \"object\" === typeof a) {\n      var b = !!a.capture;\n      var c = !!a.once;\n      var d = !!a.passive;\n      var e = a.o;\n    } else b = !!a, d = c = !1;\n\n    return {\n      P: e,\n      capture: b,\n      once: c,\n      passive: d,\n      O: ab ? a : b\n    };\n  }\n\n  var cb = {\n    blur: !0,\n    focus: !0,\n    focusin: !0,\n    focusout: !0,\n    click: !0,\n    dblclick: !0,\n    mousedown: !0,\n    mouseenter: !0,\n    mouseleave: !0,\n    mousemove: !0,\n    mouseout: !0,\n    mouseover: !0,\n    mouseup: !0,\n    wheel: !0,\n    beforeinput: !0,\n    input: !0,\n    keydown: !0,\n    keyup: !0,\n    compositionstart: !0,\n    compositionupdate: !0,\n    compositionend: !0,\n    touchstart: !0,\n    touchend: !0,\n    touchmove: !0,\n    touchcancel: !0,\n    pointerover: !0,\n    pointerenter: !0,\n    pointerdown: !0,\n    pointermove: !0,\n    pointerup: !0,\n    pointercancel: !0,\n    pointerout: !0,\n    pointerleave: !0,\n    gotpointercapture: !0,\n    lostpointercapture: !0,\n    dragstart: !0,\n    drag: !0,\n    dragenter: !0,\n    dragleave: !0,\n    dragover: !0,\n    drop: !0,\n    dragend: !0,\n    DOMActivate: !0,\n    DOMFocusIn: !0,\n    DOMFocusOut: !0,\n    keypress: !0\n  },\n      db = {\n    DOMAttrModified: !0,\n    DOMAttributeNameChanged: !0,\n    DOMCharacterDataModified: !0,\n    DOMElementNameChanged: !0,\n    DOMNodeInserted: !0,\n    DOMNodeInsertedIntoDocument: !0,\n    DOMNodeRemoved: !0,\n    DOMNodeRemovedFromDocument: !0,\n    DOMSubtreeModified: !0\n  };\n\n  function eb(a) {\n    return a instanceof Node ? a.__shady_getRootNode() : a;\n  }\n\n  function L(a, b) {\n    var c = [],\n        d = a;\n\n    for (a = eb(a); d;) c.push(d), d = d.__shady_assignedSlot ? d.__shady_assignedSlot : d.nodeType === Node.DOCUMENT_FRAGMENT_NODE && d.host && (b || d !== a) ? d.host : d.__shady_parentNode;\n\n    c[c.length - 1] === document && c.push(window);\n    return c;\n  }\n\n  function fb(a) {\n    a.__composedPath || (a.__composedPath = L(a.target, !0));\n    return a.__composedPath;\n  }\n\n  function gb(a, b) {\n    if (!w) return a;\n    a = L(a, !0);\n\n    for (var c = 0, d, e = void 0, f, g = void 0; c < b.length; c++) if (d = b[c], f = eb(d), f !== e && (g = a.indexOf(f), e = f), !w(f) || -1 < g) return d;\n  }\n\n  function hb(a) {\n    function b(c, d) {\n      c = new a(c, d);\n      c.__composed = d && !!d.composed;\n      return c;\n    }\n\n    b.__proto__ = a;\n    b.prototype = a.prototype;\n    return b;\n  }\n\n  var ib = {\n    focus: !0,\n    blur: !0\n  };\n\n  function jb(a) {\n    return a.__target !== a.target || a.__relatedTarget !== a.relatedTarget;\n  }\n\n  function kb(a, b, c) {\n    if (c = b.__handlers && b.__handlers[a.type] && b.__handlers[a.type][c]) for (var d = 0, e; (e = c[d]) && (!jb(a) || a.target !== a.relatedTarget) && (e.call(b, a), !a.__immediatePropagationStopped); d++);\n  }\n\n  function lb(a) {\n    var b = a.composedPath(),\n        c = b.map(function (m) {\n      return gb(m, b);\n    }),\n        d = a.bubbles;\n    Object.defineProperty(a, \"currentTarget\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return g;\n      }\n    });\n    var e = Event.CAPTURING_PHASE;\n    Object.defineProperty(a, \"eventPhase\", {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return e;\n      }\n    });\n\n    for (var f = b.length - 1; 0 <= f; f--) {\n      var g = b[f];\n      e = g === c[f] ? Event.AT_TARGET : Event.CAPTURING_PHASE;\n      kb(a, g, \"capture\");\n      if (a.H) return;\n    }\n\n    for (f = 0; f < b.length; f++) {\n      g = b[f];\n      var h = g === c[f];\n      if (h || d) if (e = h ? Event.AT_TARGET : Event.BUBBLING_PHASE, kb(a, g, \"bubble\"), a.H) return;\n    }\n\n    e = 0;\n    g = null;\n  }\n\n  function mb(a, b, c, d, e, f) {\n    for (var g = 0; g < a.length; g++) {\n      var h = a[g],\n          m = h.type,\n          l = h.capture,\n          k = h.once,\n          r = h.passive;\n      if (b === h.node && c === m && d === l && e === k && f === r) return g;\n    }\n\n    return -1;\n  }\n\n  function nb(a) {\n    E();\n    return !u.A && this instanceof Node && !pa(document, this) ? (a.__target || ob(a, this), lb(a)) : this.__shady_native_dispatchEvent(a);\n  }\n\n  function pb(a, b, c) {\n    var d = bb(c),\n        e = d.capture,\n        f = d.once,\n        g = d.passive,\n        h = d.P;\n    d = d.O;\n\n    if (b) {\n      var m = typeof b;\n      if (\"function\" === m || \"object\" === m) if (\"object\" !== m || b.handleEvent && \"function\" === typeof b.handleEvent) {\n        if (db[a]) return this.__shady_native_addEventListener(a, b, d);\n        var l = h || this;\n\n        if (h = b[K]) {\n          if (-1 < mb(h, l, a, e, f, g)) return;\n        } else b[K] = [];\n\n        h = function (k) {\n          f && this.__shady_removeEventListener(a, b, c);\n          k.__target || ob(k);\n\n          if (l !== this) {\n            var r = Object.getOwnPropertyDescriptor(k, \"currentTarget\");\n            Object.defineProperty(k, \"currentTarget\", {\n              get: function () {\n                return l;\n              },\n              configurable: !0\n            });\n            var C = Object.getOwnPropertyDescriptor(k, \"eventPhase\");\n            Object.defineProperty(k, \"eventPhase\", {\n              configurable: !0,\n              enumerable: !0,\n              get: function () {\n                return e ? Event.CAPTURING_PHASE : Event.BUBBLING_PHASE;\n              }\n            });\n          }\n\n          k.__previousCurrentTarget = k.currentTarget;\n          if (!w(l) && \"slot\" !== l.localName || -1 != k.composedPath().indexOf(l)) if (k.composed || -1 < k.composedPath().indexOf(l)) if (jb(k) && k.target === k.relatedTarget) k.eventPhase === Event.BUBBLING_PHASE && k.stopImmediatePropagation();else if (k.eventPhase === Event.CAPTURING_PHASE || k.bubbles || k.target === l || l instanceof Window) {\n            var P = \"function\" === m ? b.call(l, k) : b.handleEvent && b.handleEvent(k);\n            l !== this && (r ? (Object.defineProperty(k, \"currentTarget\", r), r = null) : delete k.currentTarget, C ? (Object.defineProperty(k, \"eventPhase\", C), C = null) : delete k.eventPhase);\n            return P;\n          }\n        };\n\n        b[K].push({\n          node: l,\n          type: a,\n          capture: e,\n          once: f,\n          passive: g,\n          aa: h\n        });\n        this.__handlers = this.__handlers || {};\n        this.__handlers[a] = this.__handlers[a] || {\n          capture: [],\n          bubble: []\n        };\n\n        this.__handlers[a][e ? \"capture\" : \"bubble\"].push(h);\n\n        ib[a] || this.__shady_native_addEventListener(a, h, d);\n      }\n    }\n  }\n\n  function qb(a, b, c) {\n    if (b) {\n      var d = bb(c);\n      c = d.capture;\n      var e = d.once,\n          f = d.passive,\n          g = d.P;\n      d = d.O;\n      if (db[a]) return this.__shady_native_removeEventListener(a, b, d);\n      var h = g || this;\n      g = void 0;\n      var m = null;\n\n      try {\n        m = b[K];\n      } catch (l) {}\n\n      m && (e = mb(m, h, a, c, e, f), -1 < e && (g = m.splice(e, 1)[0].aa, m.length || (b[K] = void 0)));\n\n      this.__shady_native_removeEventListener(a, g || b, d);\n\n      g && this.__handlers && this.__handlers[a] && (a = this.__handlers[a][c ? \"capture\" : \"bubble\"], b = a.indexOf(g), -1 < b && a.splice(b, 1));\n    }\n  }\n\n  function rb() {\n    for (var a in ib) window.__shady_native_addEventListener(a, function (b) {\n      b.__target || (ob(b), lb(b));\n    }, !0);\n  }\n\n  var sb = A({\n    get composed() {\n      void 0 === this.__composed && ($a ? this.__composed = \"focusin\" === this.type || \"focusout\" === this.type || $a(this) : !1 !== this.isTrusted && (this.__composed = cb[this.type]));\n      return this.__composed || !1;\n    },\n\n    composedPath: function () {\n      this.__composedPath || (this.__composedPath = L(this.__target, this.composed));\n      return this.__composedPath;\n    },\n\n    get target() {\n      return gb(this.currentTarget || this.__previousCurrentTarget, this.composedPath());\n    },\n\n    get relatedTarget() {\n      if (!this.__relatedTarget) return null;\n      this.__relatedTargetComposedPath || (this.__relatedTargetComposedPath = L(this.__relatedTarget, !0));\n      return gb(this.currentTarget || this.__previousCurrentTarget, this.__relatedTargetComposedPath);\n    },\n\n    stopPropagation: function () {\n      Event.prototype.stopPropagation.call(this);\n      this.H = !0;\n    },\n    stopImmediatePropagation: function () {\n      Event.prototype.stopImmediatePropagation.call(this);\n      this.H = this.__immediatePropagationStopped = !0;\n    }\n  });\n\n  function ob(a, b) {\n    b = void 0 === b ? a.target : b;\n    a.__target = b;\n    a.__relatedTarget = a.relatedTarget;\n\n    if (u.i) {\n      b = Object.getPrototypeOf(a);\n\n      if (!b.hasOwnProperty(\"__shady_patchedProto\")) {\n        var c = Object.create(b);\n        c.__shady_sourceProto = b;\n        z(c, sb);\n        b.__shady_patchedProto = c;\n      }\n\n      a.__proto__ = b.__shady_patchedProto;\n    } else z(a, sb);\n  }\n\n  var tb = hb(Event),\n      ub = hb(CustomEvent),\n      vb = hb(MouseEvent);\n\n  function wb() {\n    if (!$a && Object.getOwnPropertyDescriptor(Event.prototype, \"isTrusted\")) {\n      var a = function () {\n        var b = new MouseEvent(\"click\", {\n          bubbles: !0,\n          cancelable: !0,\n          composed: !0\n        });\n\n        this.__shady_dispatchEvent(b);\n      };\n\n      Element.prototype.click ? Element.prototype.click = a : HTMLElement.prototype.click && (HTMLElement.prototype.click = a);\n    }\n  }\n\n  var xb = Object.getOwnPropertyNames(Element.prototype).filter(function (a) {\n    return \"on\" === a.substring(0, 2);\n  }),\n      yb = Object.getOwnPropertyNames(HTMLElement.prototype).filter(function (a) {\n    return \"on\" === a.substring(0, 2);\n  });\n\n  function zb(a) {\n    return {\n      set: function (b) {\n        var c = q(this),\n            d = a.substring(2);\n        c.m || (c.m = {});\n        c.m[a] && this.removeEventListener(d, c.m[a]);\n\n        this.__shady_addEventListener(d, b);\n\n        c.m[a] = b;\n      },\n      get: function () {\n        var b = t(this);\n        return b && b.m && b.m[a];\n      },\n      configurable: !0\n    };\n  }\n\n  ;\n\n  function M(a, b) {\n    return {\n      index: a,\n      B: [],\n      D: b\n    };\n  }\n\n  function Ab(a, b, c, d) {\n    var e = 0,\n        f = 0,\n        g = 0,\n        h = 0,\n        m = Math.min(b - e, d - f);\n    if (0 == e && 0 == f) a: {\n      for (g = 0; g < m; g++) if (a[g] !== c[g]) break a;\n\n      g = m;\n    }\n\n    if (b == a.length && d == c.length) {\n      h = a.length;\n\n      for (var l = c.length, k = 0; k < m - g && Bb(a[--h], c[--l]);) k++;\n\n      h = k;\n    }\n\n    e += g;\n    f += g;\n    b -= h;\n    d -= h;\n    if (0 == b - e && 0 == d - f) return [];\n\n    if (e == b) {\n      for (b = M(e, 0); f < d;) b.B.push(c[f++]);\n\n      return [b];\n    }\n\n    if (f == d) return [M(e, b - e)];\n    m = e;\n    g = f;\n    d = d - g + 1;\n    h = b - m + 1;\n    b = Array(d);\n\n    for (l = 0; l < d; l++) b[l] = Array(h), b[l][0] = l;\n\n    for (l = 0; l < h; l++) b[0][l] = l;\n\n    for (l = 1; l < d; l++) for (k = 1; k < h; k++) if (a[m + k - 1] === c[g + l - 1]) b[l][k] = b[l - 1][k - 1];else {\n      var r = b[l - 1][k] + 1,\n          C = b[l][k - 1] + 1;\n      b[l][k] = r < C ? r : C;\n    }\n\n    m = b.length - 1;\n    g = b[0].length - 1;\n    d = b[m][g];\n\n    for (a = []; 0 < m || 0 < g;) 0 == m ? (a.push(2), g--) : 0 == g ? (a.push(3), m--) : (h = b[m - 1][g - 1], l = b[m - 1][g], k = b[m][g - 1], r = l < k ? l < h ? l : h : k < h ? k : h, r == h ? (h == d ? a.push(0) : (a.push(1), d = h), m--, g--) : r == l ? (a.push(3), m--, d = l) : (a.push(2), g--, d = k));\n\n    a.reverse();\n    b = void 0;\n    m = [];\n\n    for (g = 0; g < a.length; g++) switch (a[g]) {\n      case 0:\n        b && (m.push(b), b = void 0);\n        e++;\n        f++;\n        break;\n\n      case 1:\n        b || (b = M(e, 0));\n        b.D++;\n        e++;\n        b.B.push(c[f]);\n        f++;\n        break;\n\n      case 2:\n        b || (b = M(e, 0));\n        b.D++;\n        e++;\n        break;\n\n      case 3:\n        b || (b = M(e, 0)), b.B.push(c[f]), f++;\n    }\n\n    b && m.push(b);\n    return m;\n  }\n\n  function Bb(a, b) {\n    return a === b;\n  }\n\n  ;\n  var Cb = A({\n    dispatchEvent: nb,\n    addEventListener: pb,\n    removeEventListener: qb\n  });\n  var Db = null;\n\n  function N() {\n    Db || (Db = window.ShadyCSS && window.ShadyCSS.ScopingShim);\n    return Db || null;\n  }\n\n  function Eb(a, b, c) {\n    var d = N();\n    return d && \"class\" === b ? (d.setElementClass(a, c), !0) : !1;\n  }\n\n  function Fb(a, b) {\n    var c = N();\n    c && c.unscopeNode(a, b);\n  }\n\n  function Gb(a, b) {\n    var c = N();\n    if (!c) return !0;\n\n    if (a.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      c = !0;\n\n      for (a = a.__shady_firstChild; a; a = a.__shady_nextSibling) c = c && Gb(a, b);\n\n      return c;\n    }\n\n    return a.nodeType !== Node.ELEMENT_NODE ? !0 : c.currentScopeForNode(a) === b;\n  }\n\n  function O(a) {\n    if (a.nodeType !== Node.ELEMENT_NODE) return \"\";\n    var b = N();\n    return b ? b.currentScopeForNode(a) : \"\";\n  }\n\n  function Hb(a, b) {\n    if (a) for (a.nodeType === Node.ELEMENT_NODE && b(a), a = a.__shady_firstChild; a; a = a.__shady_nextSibling) a.nodeType === Node.ELEMENT_NODE && Hb(a, b);\n  }\n\n  ;\n  var Ib = window.document,\n      Jb = u.A,\n      Kb = Object.getOwnPropertyDescriptor(Node.prototype, \"isConnected\"),\n      Lb = Kb && Kb.get;\n\n  function Mb(a) {\n    for (var b; b = a.__shady_firstChild;) a.__shady_removeChild(b);\n  }\n\n  function Nb(a) {\n    var b = t(a);\n    if (b && void 0 !== b.G) for (b = a.__shady_firstChild; b; b = b.__shady_nextSibling) Nb(b);\n    if (a = t(a)) a.G = void 0;\n  }\n\n  function Ob(a) {\n    var b = a;\n\n    if (a && \"slot\" === a.localName) {\n      var c = t(a);\n      (c = c && c.u) && (b = c.length ? c[0] : Ob(a.__shady_nextSibling));\n    }\n\n    return b;\n  }\n\n  function Pb(a, b, c) {\n    if (a = (a = t(a)) && a.v) {\n      if (b) if (b.nodeType === Node.DOCUMENT_FRAGMENT_NODE) for (var d = 0, e = b.childNodes.length; d < e; d++) a.addedNodes.push(b.childNodes[d]);else a.addedNodes.push(b);\n      c && a.removedNodes.push(c);\n      Aa(a);\n    }\n  }\n\n  var S = A({\n    get parentNode() {\n      var a = t(this);\n      a = a && a.parentNode;\n      return void 0 !== a ? a : this.__shady_native_parentNode;\n    },\n\n    get firstChild() {\n      var a = t(this);\n      a = a && a.firstChild;\n      return void 0 !== a ? a : this.__shady_native_firstChild;\n    },\n\n    get lastChild() {\n      var a = t(this);\n      a = a && a.lastChild;\n      return void 0 !== a ? a : this.__shady_native_lastChild;\n    },\n\n    get nextSibling() {\n      var a = t(this);\n      a = a && a.nextSibling;\n      return void 0 !== a ? a : this.__shady_native_nextSibling;\n    },\n\n    get previousSibling() {\n      var a = t(this);\n      a = a && a.previousSibling;\n      return void 0 !== a ? a : this.__shady_native_previousSibling;\n    },\n\n    get childNodes() {\n      if (v(this)) {\n        var a = t(this);\n\n        if (!a.childNodes) {\n          a.childNodes = [];\n\n          for (var b = this.__shady_firstChild; b; b = b.__shady_nextSibling) a.childNodes.push(b);\n        }\n\n        var c = a.childNodes;\n      } else c = this.__shady_native_childNodes;\n\n      c.item = function (d) {\n        return c[d];\n      };\n\n      return c;\n    },\n\n    get parentElement() {\n      var a = t(this);\n      (a = a && a.parentNode) && a.nodeType !== Node.ELEMENT_NODE && (a = null);\n      return void 0 !== a ? a : this.__shady_native_parentElement;\n    },\n\n    get isConnected() {\n      if (Lb && Lb.call(this)) return !0;\n      if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) return !1;\n      var a = this.ownerDocument;\n      if (null === a || pa(a, this)) return !0;\n\n      for (a = this; a && !(a instanceof Document);) a = a.__shady_parentNode || (w(a) ? a.host : void 0);\n\n      return !!(a && a instanceof Document);\n    },\n\n    get textContent() {\n      if (v(this)) {\n        for (var a = [], b = this.__shady_firstChild; b; b = b.__shady_nextSibling) b.nodeType !== Node.COMMENT_NODE && a.push(b.__shady_textContent);\n\n        return a.join(\"\");\n      }\n\n      return this.__shady_native_textContent;\n    },\n\n    set textContent(a) {\n      if (\"undefined\" === typeof a || null === a) a = \"\";\n\n      switch (this.nodeType) {\n        case Node.ELEMENT_NODE:\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          if (!v(this) && u.i) {\n            var b = this.__shady_firstChild;\n            (b != this.__shady_lastChild || b && b.nodeType != Node.TEXT_NODE) && Mb(this);\n            this.__shady_native_textContent = a;\n          } else Mb(this), (0 < a.length || this.nodeType === Node.ELEMENT_NODE) && this.__shady_insertBefore(document.createTextNode(a));\n\n          break;\n\n        default:\n          this.nodeValue = a;\n      }\n    },\n\n    insertBefore: function (a, b) {\n      if (this.ownerDocument !== Ib && a.ownerDocument !== Ib) return this.__shady_native_insertBefore(a, b), a;\n      if (a === this) throw Error(\"Failed to execute 'appendChild' on 'Node': The new child element contains the parent.\");\n\n      if (b) {\n        var c = t(b);\n        c = c && c.parentNode;\n        if (void 0 !== c && c !== this || void 0 === c && b.__shady_native_parentNode !== this) throw Error(\"Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.\");\n      }\n\n      if (b === a) return a;\n      Pb(this, a);\n      var d = [],\n          e = (c = Q(this)) ? c.host.localName : O(this),\n          f = a.__shady_parentNode;\n\n      if (f) {\n        var g = O(a);\n        var h = !!c || !Q(a) || Jb && void 0 !== this.__noInsertionPoint;\n\n        f.__shady_removeChild(a, h);\n      }\n\n      f = !0;\n      var m = (!Jb || void 0 === a.__noInsertionPoint && void 0 === this.__noInsertionPoint) && !Gb(a, e),\n          l = c && !a.__noInsertionPoint && (!Jb || a.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n      if (l || m) m && (g = g || O(a)), Hb(a, function (k) {\n        l && \"slot\" === k.localName && d.push(k);\n\n        if (m) {\n          var r = g;\n          N() && (r && Fb(k, r), (r = N()) && r.scopeNode(k, e));\n        }\n      });\n      d.length && (Qb(c), c.j.push.apply(c.j, p(d)), R(c));\n      v(this) && (Rb(a, this, b), h = t(this), h.root ? (f = !1, ia(this) && R(h.root)) : c && \"slot\" === this.localName && (f = !1, R(c)));\n      f ? (c = w(this) ? this.host : this, b ? (b = Ob(b), c.__shady_native_insertBefore(a, b)) : c.__shady_native_appendChild(a)) : a.ownerDocument !== this.ownerDocument && this.ownerDocument.adoptNode(a);\n      return a;\n    },\n    appendChild: function (a) {\n      if (this != a || !w(a)) return this.__shady_insertBefore(a);\n    },\n    removeChild: function (a, b) {\n      b = void 0 === b ? !1 : b;\n      if (this.ownerDocument !== Ib) return this.__shady_native_removeChild(a);\n      if (a.__shady_parentNode !== this) throw Error(\"The node to be removed is not a child of this node: \" + a);\n      Pb(this, null, a);\n      var c = Q(a),\n          d = c && Sb(c, a),\n          e = t(this);\n\n      if (v(this) && (Tb(a, this), ia(this))) {\n        R(e.root);\n        var f = !0;\n      }\n\n      if (N() && !b && c && a.nodeType !== Node.TEXT_NODE) {\n        var g = O(a);\n        Hb(a, function (h) {\n          Fb(h, g);\n        });\n      }\n\n      Nb(a);\n      c && ((b = \"slot\" === this.localName) && (f = !0), (d || b) && R(c));\n      f || (f = w(this) ? this.host : this, (!e.root && \"slot\" !== a.localName || f === a.__shady_native_parentNode) && f.__shady_native_removeChild(a));\n      return a;\n    },\n    replaceChild: function (a, b) {\n      this.__shady_insertBefore(a, b);\n\n      this.__shady_removeChild(b);\n\n      return a;\n    },\n    cloneNode: function (a) {\n      if (\"template\" == this.localName) return this.__shady_native_cloneNode(a);\n\n      var b = this.__shady_native_cloneNode(!1);\n\n      if (a && b.nodeType !== Node.ATTRIBUTE_NODE) {\n        a = this.__shady_firstChild;\n\n        for (var c; a; a = a.__shady_nextSibling) c = a.__shady_cloneNode(!0), b.__shady_appendChild(c);\n      }\n\n      return b;\n    },\n    getRootNode: function (a) {\n      if (this && this.nodeType) {\n        var b = q(this),\n            c = b.G;\n        void 0 === c && (w(this) ? (c = this, b.G = c) : (c = (c = this.__shady_parentNode) ? c.__shady_getRootNode(a) : this, document.documentElement.__shady_native_contains(this) && (b.G = c)));\n        return c;\n      }\n    },\n    contains: function (a) {\n      return qa(this, a);\n    }\n  });\n  var T = A({\n    get assignedSlot() {\n      var a = this.__shady_parentNode;\n      (a = a && a.__shady_shadowRoot) && Ub(a);\n      return (a = t(this)) && a.assignedSlot || null;\n    }\n\n  });\n\n  function Vb(a, b, c) {\n    var d = [];\n    Wb(a, b, c, d);\n    return d;\n  }\n\n  function Wb(a, b, c, d) {\n    for (a = a.__shady_firstChild; a; a = a.__shady_nextSibling) {\n      var e;\n\n      if (e = a.nodeType === Node.ELEMENT_NODE) {\n        e = a;\n        var f = b,\n            g = c,\n            h = d,\n            m = f(e);\n        m && h.push(e);\n        g && g(m) ? e = m : (Wb(e, f, g, h), e = void 0);\n      }\n\n      if (e) break;\n    }\n  }\n\n  var Xb = {\n    get firstElementChild() {\n      var a = t(this);\n\n      if (a && void 0 !== a.firstChild) {\n        for (a = this.__shady_firstChild; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.__shady_nextSibling;\n\n        return a;\n      }\n\n      return this.__shady_native_firstElementChild;\n    },\n\n    get lastElementChild() {\n      var a = t(this);\n\n      if (a && void 0 !== a.lastChild) {\n        for (a = this.__shady_lastChild; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.__shady_previousSibling;\n\n        return a;\n      }\n\n      return this.__shady_native_lastElementChild;\n    },\n\n    get children() {\n      return v(this) ? y(Array.prototype.filter.call(sa(this), function (a) {\n        return a.nodeType === Node.ELEMENT_NODE;\n      })) : this.__shady_native_children;\n    },\n\n    get childElementCount() {\n      var a = this.__shady_children;\n      return a ? a.length : 0;\n    }\n\n  },\n      U = A((Xb.append = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    this.__shady_insertBefore(B.apply(null, p(b)), null);\n  }, Xb.prepend = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    this.__shady_insertBefore(B.apply(null, p(b)), this.__shady_firstChild);\n  }, Xb.replaceChildren = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    for (; null !== (c = this.__shady_firstChild);) this.__shady_removeChild(c);\n\n    this.__shady_insertBefore(B.apply(null, p(b)), null);\n  }, Xb)),\n      Yb = A({\n    querySelector: function (a) {\n      return Vb(this, function (b) {\n        return ka.call(b, a);\n      }, function (b) {\n        return !!b;\n      })[0] || null;\n    },\n    querySelectorAll: function (a, b) {\n      if (b) {\n        b = Array.prototype.slice.call(this.__shady_native_querySelectorAll(a));\n\n        var c = this.__shady_getRootNode();\n\n        return y(b.filter(function (d) {\n          return d.__shady_getRootNode() == c;\n        }));\n      }\n\n      return y(Vb(this, function (d) {\n        return ka.call(d, a);\n      }));\n    }\n  }),\n      Zb = u.A && !u.l ? va({}, U) : U;\n  va(U, Yb);\n  /*\n  Copyright (c) 2020 The Polymer Project Authors. All rights reserved.\n  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n  Code distributed by Google as part of the polymer project is also\n  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n  */\n\n  var $b = A({\n    after: function (a) {\n      for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n      c = this.__shady_parentNode;\n\n      if (null !== c) {\n        var d = this.__shady_nextSibling;\n\n        c.__shady_insertBefore(B.apply(null, p(b)), d);\n      }\n    },\n    before: function (a) {\n      for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n      c = this.__shady_parentNode;\n      null !== c && c.__shady_insertBefore(B.apply(null, p(b)), this);\n    },\n    remove: function () {\n      var a = this.__shady_parentNode;\n      null !== a && a.__shady_removeChild(this);\n    },\n    replaceWith: function (a) {\n      for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n      c = this.__shady_parentNode;\n\n      if (null !== c) {\n        var d = this.__shady_nextSibling;\n\n        c.__shady_removeChild(this);\n\n        c.__shady_insertBefore(B.apply(null, p(b)), d);\n      }\n    }\n  });\n  var ac = window.document;\n\n  function bc(a, b) {\n    if (\"slot\" === b) a = a.__shady_parentNode, ia(a) && R(t(a).root);else if (\"slot\" === a.localName && \"name\" === b && (b = Q(a))) {\n      if (b.g) {\n        cc(b);\n        var c = a.U,\n            d = dc(a);\n\n        if (d !== c) {\n          c = b.h[c];\n          var e = c.indexOf(a);\n          0 <= e && c.splice(e, 1);\n          c = b.h[d] || (b.h[d] = []);\n          c.push(a);\n          1 < c.length && (b.h[d] = ec(c));\n        }\n      }\n\n      R(b);\n    }\n  }\n\n  var fc = A({\n    get previousElementSibling() {\n      var a = t(this);\n\n      if (a && void 0 !== a.previousSibling) {\n        for (a = this.__shady_previousSibling; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.__shady_previousSibling;\n\n        return a;\n      }\n\n      return this.__shady_native_previousElementSibling;\n    },\n\n    get nextElementSibling() {\n      var a = t(this);\n\n      if (a && void 0 !== a.nextSibling) {\n        for (a = this.__shady_nextSibling; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.__shady_nextSibling;\n\n        return a;\n      }\n\n      return this.__shady_native_nextElementSibling;\n    },\n\n    get slot() {\n      return this.getAttribute(\"slot\");\n    },\n\n    set slot(a) {\n      this.__shady_setAttribute(\"slot\", a);\n    },\n\n    get className() {\n      return this.getAttribute(\"class\") || \"\";\n    },\n\n    set className(a) {\n      this.__shady_setAttribute(\"class\", a);\n    },\n\n    setAttribute: function (a, b) {\n      this.ownerDocument !== ac ? this.__shady_native_setAttribute(a, b) : Eb(this, a, b) || (this.__shady_native_setAttribute(a, b), bc(this, a));\n    },\n    removeAttribute: function (a) {\n      this.ownerDocument !== ac ? this.__shady_native_removeAttribute(a) : Eb(this, a, \"\") ? \"\" === this.getAttribute(a) && this.__shady_native_removeAttribute(a) : (this.__shady_native_removeAttribute(a), bc(this, a));\n    }\n  });\n  u.A || xb.forEach(function (a) {\n    fc[a] = zb(a);\n  });\n  var kc = A({\n    attachShadow: function (a) {\n      if (!this) throw Error(\"Must provide a host.\");\n      if (!a) throw Error(\"Not enough arguments.\");\n\n      if (a.shadyUpgradeFragment && !u.R) {\n        var b = a.shadyUpgradeFragment;\n        b.__proto__ = ShadowRoot.prototype;\n        gc(b, this, a);\n        hc(b, b);\n        a = b.__noInsertionPoint ? null : b.querySelectorAll(\"slot\");\n        b.__noInsertionPoint = void 0;\n\n        if (a && a.length) {\n          var c = b;\n          Qb(c);\n          c.j.push.apply(c.j, p(a));\n          R(b);\n        }\n\n        b.host.__shady_native_appendChild(b);\n      } else b = new ic(jc, this, a);\n\n      return this.__CE_shadowRoot = b;\n    },\n\n    get shadowRoot() {\n      var a = t(this);\n      return a && a.Z || null;\n    }\n\n  });\n  va(fc, kc);\n  var lc = document.implementation.createHTMLDocument(\"inert\"),\n      mc = A({\n    get innerHTML() {\n      return v(this) ? Ka(\"template\" === this.localName ? this.content : this, sa) : this.__shady_native_innerHTML;\n    },\n\n    set innerHTML(a) {\n      if (\"template\" === this.localName) this.__shady_native_innerHTML = a;else {\n        Mb(this);\n        var b = this.localName || \"div\";\n        b = this.namespaceURI && this.namespaceURI !== lc.namespaceURI ? lc.createElementNS(this.namespaceURI, b) : lc.createElement(b);\n\n        for (u.i ? b.__shady_native_innerHTML = a : b.innerHTML = a; a = b.__shady_firstChild;) this.__shady_insertBefore(a);\n      }\n    }\n\n  });\n  var nc = A({\n    blur: function () {\n      var a = t(this);\n      (a = (a = a && a.root) && a.activeElement) ? a.__shady_blur() : this.__shady_native_blur();\n    }\n  });\n  u.A || yb.forEach(function (a) {\n    nc[a] = zb(a);\n  });\n  var oc = A({\n    assignedNodes: function (a) {\n      if (\"slot\" === this.localName) {\n        var b = this.__shady_getRootNode();\n\n        b && w(b) && Ub(b);\n        return (b = t(this)) ? (a && a.flatten ? b.u : b.assignedNodes) || [] : [];\n      }\n    },\n    addEventListener: function (a, b, c) {\n      if (\"slot\" !== this.localName || \"slotchange\" === a) pb.call(this, a, b, c);else {\n        \"object\" !== typeof c && (c = {\n          capture: !!c\n        });\n        var d = this.__shady_parentNode;\n        if (!d) throw Error(\"ShadyDOM cannot attach event to slot unless it has a `parentNode`\");\n        c.o = this;\n\n        d.__shady_addEventListener(a, b, c);\n      }\n    },\n    removeEventListener: function (a, b, c) {\n      if (\"slot\" !== this.localName || \"slotchange\" === a) qb.call(this, a, b, c);else {\n        \"object\" !== typeof c && (c = {\n          capture: !!c\n        });\n        var d = this.__shady_parentNode;\n        if (!d) throw Error(\"ShadyDOM cannot attach event to slot unless it has a `parentNode`\");\n        c.o = this;\n\n        d.__shady_removeEventListener(a, b, c);\n      }\n    }\n  });\n  var pc = A({\n    getElementById: function (a) {\n      return \"\" === a ? null : Vb(this, function (b) {\n        return b.id == a;\n      }, function (b) {\n        return !!b;\n      })[0] || null;\n    }\n  });\n\n  function qc(a, b) {\n    for (var c; b && !a.has(c = b.__shady_getRootNode());) b = c.host;\n\n    return b;\n  }\n\n  function rc(a) {\n    var b = new Set();\n\n    for (b.add(a); w(a) && a.host;) a = a.host.__shady_getRootNode(), b.add(a);\n\n    return b;\n  }\n\n  var sc = \"__shady_native_\" + ha(),\n      tc = A({\n    get activeElement() {\n      var a = u.i ? document.__shady_native_activeElement : document.activeElement;\n      if (!a || !a.nodeType) return null;\n      var b = !!w(this);\n      if (!(this === document || b && this.host !== a && this.host.__shady_native_contains(a))) return null;\n\n      for (b = Q(a); b && b !== this;) a = b.host, b = Q(a);\n\n      return this === document ? b ? null : a : b === this ? a : null;\n    },\n\n    elementsFromPoint: function (a, b) {\n      a = [].slice.call(document[sc](a, b));\n      b = rc(this);\n\n      for (var c = new Set(), d = 0; d < a.length; d++) c.add(qc(b, a[d]));\n\n      var e = [];\n      c.forEach(function (f) {\n        return e.push(f);\n      });\n      return e;\n    },\n    elementFromPoint: function (a, b) {\n      return this.__shady_elementsFromPoint(a, b)[0] || null;\n    }\n  });\n  var uc = window.document,\n      vc = A({\n    importNode: function (a, b) {\n      if (a.ownerDocument !== uc || \"template\" === a.localName) return this.__shady_native_importNode(a, b);\n\n      var c = this.__shady_native_importNode(a, !1);\n\n      if (b) for (a = a.__shady_firstChild; a; a = a.__shady_nextSibling) b = this.__shady_importNode(a, !0), c.__shady_appendChild(b);\n      return c;\n    }\n  });\n  var wc = A({\n    dispatchEvent: nb,\n    addEventListener: pb.bind(window),\n    removeEventListener: qb.bind(window)\n  });\n  var V = {};\n  Object.getOwnPropertyDescriptor(HTMLElement.prototype, \"parentElement\") && (V.parentElement = S.parentElement);\n  Object.getOwnPropertyDescriptor(HTMLElement.prototype, \"contains\") && (V.contains = S.contains);\n  Object.getOwnPropertyDescriptor(HTMLElement.prototype, \"children\") && (V.children = U.children);\n  Object.getOwnPropertyDescriptor(HTMLElement.prototype, \"innerHTML\") && (V.innerHTML = mc.innerHTML);\n  Object.getOwnPropertyDescriptor(HTMLElement.prototype, \"className\") && (V.className = fc.className);\n  var W = {\n    EventTarget: [Cb],\n    Node: [S, window.EventTarget ? null : Cb],\n    Text: [T],\n    Comment: [T],\n    CDATASection: [T],\n    ProcessingInstruction: [T],\n    Element: [fc, U, $b, T, !u.i || \"innerHTML\" in Element.prototype ? mc : null, window.HTMLSlotElement ? null : oc],\n    HTMLElement: [nc, V],\n    HTMLSlotElement: [oc],\n    DocumentFragment: [Zb, pc],\n    Document: [vc, Zb, pc, tc],\n    Window: [wc],\n    CharacterData: [$b]\n  },\n      xc = u.i ? null : [\"innerHTML\", \"textContent\"];\n\n  function X(a, b, c, d) {\n    b.forEach(function (e) {\n      return a && e && z(a, e, c, d);\n    });\n  }\n\n  function yc(a) {\n    var b = a ? null : xc,\n        c;\n\n    for (c in W) X(window[c] && window[c].prototype, W[c], a, b);\n  }\n\n  [\"Text\", \"Comment\", \"CDATASection\", \"ProcessingInstruction\"].forEach(function (a) {\n    var b = window[a],\n        c = Object.create(b.prototype);\n    c.__shady_protoIsPatched = !0;\n    X(c, W.EventTarget);\n    X(c, W.Node);\n    W[a] && X(c, W[a]);\n    b.prototype.__shady_patchedProto = c;\n  });\n\n  function zc(a) {\n    a.__shady_protoIsPatched = !0;\n    X(a, W.EventTarget);\n    X(a, W.Node);\n    X(a, W.Element);\n    X(a, W.HTMLElement);\n    X(a, W.HTMLSlotElement);\n    return a;\n  }\n\n  ;\n  var Ac = u.L,\n      Bc = u.i;\n\n  function Cc(a, b) {\n    if (Ac && !a.__shady_protoIsPatched && !w(a)) {\n      var c = Object.getPrototypeOf(a),\n          d = c.hasOwnProperty(\"__shady_patchedProto\") && c.__shady_patchedProto;\n\n      d || (d = Object.create(c), zc(d), c.__shady_patchedProto = d);\n      Object.setPrototypeOf(a, d);\n    }\n\n    Bc || (1 === b ? Ya(a) : 2 === b && Za(a));\n  }\n\n  function Dc(a, b, c, d) {\n    Cc(a, 1);\n    d = d || null;\n    var e = q(a),\n        f = d ? q(d) : null;\n    e.previousSibling = d ? f.previousSibling : b.__shady_lastChild;\n    if (f = t(e.previousSibling)) f.nextSibling = a;\n    if (f = t(e.nextSibling = d)) f.previousSibling = a;\n    e.parentNode = b;\n    d ? d === c.firstChild && (c.firstChild = a) : (c.lastChild = a, c.firstChild || (c.firstChild = a));\n    c.childNodes = null;\n  }\n\n  function Rb(a, b, c) {\n    Cc(b, 2);\n    var d = q(b);\n    void 0 !== d.firstChild && (d.childNodes = null);\n    if (a.nodeType === Node.DOCUMENT_FRAGMENT_NODE) for (a = a.__shady_native_firstChild; a; a = a.__shady_native_nextSibling) Dc(a, b, d, c);else Dc(a, b, d, c);\n  }\n\n  function Tb(a, b) {\n    var c = q(a);\n    b = q(b);\n    a === b.firstChild && (b.firstChild = c.nextSibling);\n    a === b.lastChild && (b.lastChild = c.previousSibling);\n    a = c.previousSibling;\n    var d = c.nextSibling;\n    a && (q(a).nextSibling = d);\n    d && (q(d).previousSibling = a);\n    c.parentNode = c.previousSibling = c.nextSibling = void 0;\n    void 0 !== b.childNodes && (b.childNodes = null);\n  }\n\n  function hc(a, b) {\n    var c = q(a);\n\n    if (b || void 0 === c.firstChild) {\n      c.childNodes = null;\n      var d = c.firstChild = a.__shady_native_firstChild;\n      c.lastChild = a.__shady_native_lastChild;\n      Cc(a, 2);\n      c = d;\n\n      for (d = void 0; c; c = c.__shady_native_nextSibling) {\n        var e = q(c);\n        e.parentNode = b || a;\n        e.nextSibling = c.__shady_native_nextSibling;\n        e.previousSibling = d || null;\n        d = c;\n        Cc(c, 1);\n      }\n    }\n  }\n\n  ;\n  var Ec = A({\n    addEventListener: function (a, b, c) {\n      \"object\" !== typeof c && (c = {\n        capture: !!c\n      });\n      c.o = c.o || this;\n\n      this.host.__shady_addEventListener(a, b, c);\n    },\n    removeEventListener: function (a, b, c) {\n      \"object\" !== typeof c && (c = {\n        capture: !!c\n      });\n      c.o = c.o || this;\n\n      this.host.__shady_removeEventListener(a, b, c);\n    }\n  });\n\n  function Fc(a, b) {\n    z(a, Ec, b);\n    z(a, tc, b);\n    z(a, mc, b);\n    z(a, U, b);\n    u.l && !b ? (z(a, S, b), z(a, pc, b)) : u.i || (z(a, Va), z(a, Ta), z(a, Ua));\n  }\n\n  ;\n  var jc = {},\n      Y = u.deferConnectionCallbacks && \"loading\" === document.readyState,\n      Gc;\n\n  function Hc(a) {\n    var b = [];\n\n    do b.unshift(a); while (a = a.__shady_parentNode);\n\n    return b;\n  }\n\n  function ic(a, b, c) {\n    if (a !== jc) throw new TypeError(\"Illegal constructor\");\n    this.g = null;\n    gc(this, b, c);\n  }\n\n  function gc(a, b, c) {\n    a.host = b;\n    a.mode = c && c.mode;\n    hc(a.host);\n    b = q(a.host);\n    b.root = a;\n    b.Z = \"closed\" !== a.mode ? a : null;\n    b = q(a);\n    b.firstChild = b.lastChild = b.parentNode = b.nextSibling = b.previousSibling = null;\n    if (u.preferPerformance) for (; b = a.host.__shady_native_firstChild;) a.host.__shady_native_removeChild(b);else R(a);\n  }\n\n  function R(a) {\n    a.s || (a.s = !0, ya(function () {\n      return Ub(a);\n    }));\n  }\n\n  function Ub(a) {\n    var b;\n\n    if (b = a.s) {\n      for (var c; a;) a: {\n        a.s && (c = a), b = a;\n        a = b.host.__shady_getRootNode();\n        if (w(a) && (b = t(b.host)) && 0 < b.C) break a;\n        a = void 0;\n      }\n\n      b = c;\n    }\n\n    (c = b) && c._renderSelf();\n  }\n\n  ic.prototype._renderSelf = function () {\n    var a = Y;\n    Y = !0;\n    this.s = !1;\n\n    if (this.g) {\n      cc(this);\n\n      for (var b = 0, c; b < this.g.length; b++) {\n        c = this.g[b];\n        var d = t(c),\n            e = d.assignedNodes;\n        d.assignedNodes = [];\n        d.u = [];\n        if (d.N = e) for (d = 0; d < e.length; d++) {\n          var f = t(e[d]);\n          f.I = f.assignedSlot;\n          f.assignedSlot === c && (f.assignedSlot = null);\n        }\n      }\n\n      for (b = this.host.__shady_firstChild; b; b = b.__shady_nextSibling) Ic(this, b);\n\n      for (b = 0; b < this.g.length; b++) {\n        c = this.g[b];\n        e = t(c);\n        if (!e.assignedNodes.length) for (d = c.__shady_firstChild; d; d = d.__shady_nextSibling) Ic(this, d, c);\n        (d = (d = t(c.__shady_parentNode)) && d.root) && (ja(d) || d.s) && d._renderSelf();\n        Jc(this, e.u, e.assignedNodes);\n\n        if (d = e.N) {\n          for (f = 0; f < d.length; f++) t(d[f]).I = null;\n\n          e.N = null;\n          d.length > e.assignedNodes.length && (e.J = !0);\n        }\n\n        e.J && (e.J = !1, Kc(this, c));\n      }\n\n      c = this.g;\n      b = [];\n\n      for (e = 0; e < c.length; e++) d = c[e].__shady_parentNode, (f = t(d)) && f.root || !(0 > b.indexOf(d)) || b.push(d);\n\n      for (c = 0; c < b.length; c++) {\n        f = b[c];\n        e = f === this ? this.host : f;\n        d = [];\n\n        for (f = f.__shady_firstChild; f; f = f.__shady_nextSibling) if (\"slot\" == f.localName) for (var g = t(f).u, h = 0; h < g.length; h++) d.push(g[h]);else d.push(f);\n\n        f = ra(e);\n        g = Ab(d, d.length, f, f.length);\n\n        for (var m = h = 0, l = void 0; h < g.length && (l = g[h]); h++) {\n          for (var k = 0, r = void 0; k < l.B.length && (r = l.B[k]); k++) r.__shady_native_parentNode === e && e.__shady_native_removeChild(r), f.splice(l.index + m, 1);\n\n          m -= l.D;\n        }\n\n        m = 0;\n\n        for (l = void 0; m < g.length && (l = g[m]); m++) for (h = f[l.index], k = l.index; k < l.index + l.D; k++) r = d[k], e.__shady_native_insertBefore(r, h), f.splice(k, 0, r);\n      }\n    }\n\n    if (!u.preferPerformance && !this.M) for (b = this.host.__shady_firstChild; b; b = b.__shady_nextSibling) c = t(b), b.__shady_native_parentNode !== this.host || \"slot\" !== b.localName && c.assignedSlot || this.host.__shady_native_removeChild(b);\n    this.M = !0;\n    Y = a;\n    Gc && Gc();\n  };\n\n  function Ic(a, b, c) {\n    var d = q(b),\n        e = d.I;\n    d.I = null;\n    c || (c = (a = a.h[b.__shady_slot || \"__catchall\"]) && a[0]);\n    c ? (q(c).assignedNodes.push(b), d.assignedSlot = c) : d.assignedSlot = void 0;\n    e !== d.assignedSlot && d.assignedSlot && (q(d.assignedSlot).J = !0);\n  }\n\n  function Jc(a, b, c) {\n    for (var d = 0, e = void 0; d < c.length && (e = c[d]); d++) if (\"slot\" == e.localName) {\n      var f = t(e).assignedNodes;\n      f && f.length && Jc(a, b, f);\n    } else b.push(c[d]);\n  }\n\n  function Kc(a, b) {\n    b.__shady_native_dispatchEvent(new Event(\"slotchange\"));\n\n    b = t(b);\n    b.assignedSlot && Kc(a, b.assignedSlot);\n  }\n\n  function Qb(a) {\n    a.j = a.j || [];\n    a.g = a.g || [];\n    a.h = a.h || {};\n  }\n\n  function cc(a) {\n    if (a.j && a.j.length) {\n      for (var b = a.j, c, d = 0; d < b.length; d++) {\n        var e = b[d];\n        hc(e);\n        var f = e.__shady_parentNode;\n        hc(f);\n        f = t(f);\n        f.C = (f.C || 0) + 1;\n        f = dc(e);\n        a.h[f] ? (c = c || {}, c[f] = !0, a.h[f].push(e)) : a.h[f] = [e];\n        a.g.push(e);\n      }\n\n      if (c) for (var g in c) a.h[g] = ec(a.h[g]);\n      a.j = [];\n    }\n  }\n\n  function dc(a) {\n    var b = a.name || a.getAttribute(\"name\") || \"__catchall\";\n    return a.U = b;\n  }\n\n  function ec(a) {\n    return a.sort(function (b, c) {\n      b = Hc(b);\n\n      for (var d = Hc(c), e = 0; e < b.length; e++) {\n        c = b[e];\n        var f = d[e];\n        if (c !== f) return b = sa(c.__shady_parentNode), b.indexOf(c) - b.indexOf(f);\n      }\n    });\n  }\n\n  function Sb(a, b) {\n    if (a.g) {\n      cc(a);\n      var c = a.h,\n          d;\n\n      for (d in c) for (var e = c[d], f = 0; f < e.length; f++) {\n        var g = e[f];\n\n        if (qa(b, g)) {\n          e.splice(f, 1);\n          var h = a.g.indexOf(g);\n          0 <= h && (a.g.splice(h, 1), (h = t(g.__shady_parentNode)) && h.C && h.C--);\n          f--;\n          g = t(g);\n          if (h = g.u) for (var m = 0; m < h.length; m++) {\n            var l = h[m],\n                k = l.__shady_native_parentNode;\n            k && k.__shady_native_removeChild(l);\n          }\n          g.u = [];\n          g.assignedNodes = [];\n          h = !0;\n        }\n      }\n\n      return h;\n    }\n  }\n\n  function ja(a) {\n    cc(a);\n    return !(!a.g || !a.g.length);\n  }\n\n  (function (a) {\n    a.__proto__ = DocumentFragment.prototype;\n    Fc(a, \"__shady_\");\n    Fc(a);\n    Object.defineProperties(a, {\n      nodeType: {\n        value: Node.DOCUMENT_FRAGMENT_NODE,\n        configurable: !0\n      },\n      nodeName: {\n        value: \"#document-fragment\",\n        configurable: !0\n      },\n      nodeValue: {\n        value: null,\n        configurable: !0\n      }\n    });\n    [\"localName\", \"namespaceURI\", \"prefix\"].forEach(function (b) {\n      Object.defineProperty(a, b, {\n        value: void 0,\n        configurable: !0\n      });\n    });\n    [\"ownerDocument\", \"baseURI\", \"isConnected\"].forEach(function (b) {\n      Object.defineProperty(a, b, {\n        get: function () {\n          return this.host[b];\n        },\n        configurable: !0\n      });\n    });\n  })(ic.prototype);\n\n  if (window.customElements && window.customElements.define && u.K && !u.preferPerformance) {\n    var Lc = new Map();\n\n    Gc = function () {\n      var a = [];\n      Lc.forEach(function (d, e) {\n        a.push([e, d]);\n      });\n      Lc.clear();\n\n      for (var b = 0; b < a.length; b++) {\n        var c = a[b][0];\n        a[b][1] ? c.__shadydom_connectedCallback() : c.__shadydom_disconnectedCallback();\n      }\n    };\n\n    Y && document.addEventListener(\"readystatechange\", function () {\n      Y = !1;\n      Gc();\n    }, {\n      once: !0\n    });\n\n    var Mc = function (a, b, c) {\n      var d = 0,\n          e = \"__isConnected\" + d++;\n      if (b || c) a.prototype.connectedCallback = a.prototype.__shadydom_connectedCallback = function () {\n        Y ? Lc.set(this, !0) : this[e] || (this[e] = !0, b && b.call(this));\n      }, a.prototype.disconnectedCallback = a.prototype.__shadydom_disconnectedCallback = function () {\n        Y ? this.isConnected || Lc.set(this, !1) : this[e] && (this[e] = !1, c && c.call(this));\n      };\n      return a;\n    },\n        Nc = window.customElements.define,\n        Oc = function (a, b) {\n      var c = b.prototype.connectedCallback,\n          d = b.prototype.disconnectedCallback;\n      Nc.call(window.customElements, a, Mc(b, c, d));\n      b.prototype.connectedCallback = c;\n      b.prototype.disconnectedCallback = d;\n    };\n\n    window.customElements.define = Oc;\n    Object.defineProperty(window.CustomElementRegistry.prototype, \"define\", {\n      value: Oc,\n      configurable: !0\n    });\n  }\n\n  function Q(a) {\n    a = a.__shady_getRootNode();\n    if (w(a)) return a;\n  }\n\n  ;\n\n  function Z(a) {\n    this.node = a;\n  }\n\n  n = Z.prototype;\n\n  n.addEventListener = function (a, b, c) {\n    return this.node.__shady_addEventListener(a, b, c);\n  };\n\n  n.removeEventListener = function (a, b, c) {\n    return this.node.__shady_removeEventListener(a, b, c);\n  };\n\n  n.appendChild = function (a) {\n    return this.node.__shady_appendChild(a);\n  };\n\n  n.insertBefore = function (a, b) {\n    return this.node.__shady_insertBefore(a, b);\n  };\n\n  n.removeChild = function (a) {\n    return this.node.__shady_removeChild(a);\n  };\n\n  n.replaceChild = function (a, b) {\n    return this.node.__shady_replaceChild(a, b);\n  };\n\n  n.cloneNode = function (a) {\n    return this.node.__shady_cloneNode(a);\n  };\n\n  n.getRootNode = function (a) {\n    return this.node.__shady_getRootNode(a);\n  };\n\n  n.contains = function (a) {\n    return this.node.__shady_contains(a);\n  };\n\n  n.dispatchEvent = function (a) {\n    return this.node.__shady_dispatchEvent(a);\n  };\n\n  n.setAttribute = function (a, b) {\n    this.node.__shady_setAttribute(a, b);\n  };\n\n  n.getAttribute = function (a) {\n    return this.node.__shady_native_getAttribute(a);\n  };\n\n  n.removeAttribute = function (a) {\n    this.node.__shady_removeAttribute(a);\n  };\n\n  n.attachShadow = function (a) {\n    return this.node.__shady_attachShadow(a);\n  };\n\n  n.focus = function () {\n    this.node.__shady_native_focus();\n  };\n\n  n.blur = function () {\n    this.node.__shady_blur();\n  };\n\n  n.importNode = function (a, b) {\n    if (this.node.nodeType === Node.DOCUMENT_NODE) return this.node.__shady_importNode(a, b);\n  };\n\n  n.getElementById = function (a) {\n    if (this.node.nodeType === Node.DOCUMENT_NODE) return this.node.__shady_getElementById(a);\n  };\n\n  n.elementsFromPoint = function (a, b) {\n    return this.node.__shady_elementsFromPoint(a, b);\n  };\n\n  n.elementFromPoint = function (a, b) {\n    return this.node.__shady_elementFromPoint(a, b);\n  };\n\n  n.querySelector = function (a) {\n    return this.node.__shady_querySelector(a);\n  };\n\n  n.querySelectorAll = function (a, b) {\n    return this.node.__shady_querySelectorAll(a, b);\n  };\n\n  n.assignedNodes = function (a) {\n    if (\"slot\" === this.node.localName) return this.node.__shady_assignedNodes(a);\n  };\n\n  n.append = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    return this.node.__shady_append.apply(this.node, p(b));\n  };\n\n  n.prepend = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    return this.node.__shady_prepend.apply(this.node, p(b));\n  };\n\n  n.after = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    return this.node.__shady_after.apply(this.node, p(b));\n  };\n\n  n.before = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    return this.node.__shady_before.apply(this.node, p(b));\n  };\n\n  n.remove = function () {\n    return this.node.__shady_remove();\n  };\n\n  n.replaceWith = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) b[c] = arguments[c];\n\n    return this.node.__shady_replaceWith.apply(this.node, p(b));\n  };\n\n  da.Object.defineProperties(Z.prototype, {\n    activeElement: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        if (w(this.node) || this.node.nodeType === Node.DOCUMENT_NODE) return this.node.__shady_activeElement;\n      }\n    },\n    _activeElement: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.activeElement;\n      }\n    },\n    host: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        if (w(this.node)) return this.node.host;\n      }\n    },\n    parentNode: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_parentNode;\n      }\n    },\n    firstChild: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_firstChild;\n      }\n    },\n    lastChild: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_lastChild;\n      }\n    },\n    nextSibling: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_nextSibling;\n      }\n    },\n    previousSibling: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_previousSibling;\n      }\n    },\n    childNodes: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_childNodes;\n      }\n    },\n    parentElement: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_parentElement;\n      }\n    },\n    firstElementChild: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_firstElementChild;\n      }\n    },\n    lastElementChild: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_lastElementChild;\n      }\n    },\n    nextElementSibling: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_nextElementSibling;\n      }\n    },\n    previousElementSibling: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_previousElementSibling;\n      }\n    },\n    children: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_children;\n      }\n    },\n    childElementCount: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_childElementCount;\n      }\n    },\n    shadowRoot: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_shadowRoot;\n      }\n    },\n    assignedSlot: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_assignedSlot;\n      }\n    },\n    isConnected: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_isConnected;\n      }\n    },\n    innerHTML: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_innerHTML;\n      },\n      set: function (a) {\n        this.node.__shady_innerHTML = a;\n      }\n    },\n    textContent: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_textContent;\n      },\n      set: function (a) {\n        this.node.__shady_textContent = a;\n      }\n    },\n    slot: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_slot;\n      },\n      set: function (a) {\n        this.node.__shady_slot = a;\n      }\n    },\n    className: {\n      configurable: !0,\n      enumerable: !0,\n      get: function () {\n        return this.node.__shady_className;\n      },\n      set: function (a) {\n        this.node.__shady_className = a;\n      }\n    }\n  });\n\n  function Pc(a) {\n    Object.defineProperty(Z.prototype, a, {\n      get: function () {\n        return this.node[\"__shady_\" + a];\n      },\n      set: function (b) {\n        this.node[\"__shady_\" + a] = b;\n      },\n      configurable: !0\n    });\n  }\n\n  xb.forEach(function (a) {\n    return Pc(a);\n  });\n  yb.forEach(function (a) {\n    return Pc(a);\n  });\n  var Qc = new WeakMap();\n\n  function Rc(a) {\n    if (w(a) || a instanceof Z) return a;\n    var b = Qc.get(a);\n    b || (b = new Z(a), Qc.set(a, b));\n    return b;\n  }\n\n  ;\n\n  if (u.K) {\n    var Sc = u.i ? function (a) {\n      return a;\n    } : function (a) {\n      Za(a);\n      Ya(a);\n      return a;\n    };\n    window.ShadyDOM = {\n      inUse: u.K,\n      patch: Sc,\n      isShadyRoot: w,\n      enqueue: ya,\n      flush: E,\n      flushInitial: function (a) {\n        !a.M && a.s && Ub(a);\n      },\n      settings: u,\n      filterMutations: Da,\n      observeChildren: Ba,\n      unobserveChildren: Ca,\n      deferConnectionCallbacks: u.deferConnectionCallbacks,\n      preferPerformance: u.preferPerformance,\n      handlesDynamicScoping: !0,\n      wrap: u.l ? Rc : Sc,\n      wrapIfNeeded: !0 === u.l ? Rc : function (a) {\n        return a;\n      },\n      Wrapper: Z,\n      composedPath: fb,\n      noPatch: u.l,\n      patchOnDemand: u.L,\n      nativeMethods: La,\n      nativeTree: Ma,\n      patchElementProto: zc\n    };\n    Sa();\n    yc(\"__shady_\");\n    Object.defineProperty(document, \"_activeElement\", tc.activeElement);\n    z(Window.prototype, wc, \"__shady_\");\n    u.l ? u.L && z(Element.prototype, kc) : (yc(), wb());\n    rb();\n    window.Event = tb;\n    window.CustomEvent = ub;\n    window.MouseEvent = vb;\n    window.ShadowRoot = ic;\n  }\n\n  ;\n}).call(this);","map":{"version":3,"mappings":"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","names":["a","b","length","done","value","Symbol","iterator","call","next","$jscomp.arrayIteratorImpl","Array","c","push","globalThis","window","self","global","Math","Error","$jscomp.getGlobal","ShadyData","ea","ensureShadyDataForNode","node","__shady","shadyDataForNode","settings","ShadyDOM","hasNativeShadowDOM","attachShadow","prototype","Element","getRootNode","Node","desc","Object","getOwnPropertyDescriptor","hasDescriptors","configurable","get","inUse","force","noPatch","preferPerformance","patchOnDemand","IS_IE","navigator","userAgent","match","getPropertyName","Document","prefixed","name","isTrackingLogicalChildNodes","nodeData","undefined","firstChild","isShadyRoot","obj","ShadowRoot","hasShadowRootWithSlot","root","_hasInsertionPoint","p","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","twiddle","document","createTextNode","content","queue","MutationObserver","shift","e","textContent","observe","characterData","microtask","callback","documentContains","contains","doc","__shady_native_contains","documentElement","container","__shady_parentNode","createPolyfilledHTMLCollection","nodes","l","getAttribute","isNaN","item","nodes.item","index","namedItem","nodes.namedItem","f","g","nativeChildNodesArray","parent","result","n","__shady_native_firstChild","__shady_native_nextSibling","childNodesArray","__shady_firstChild","__shady_nextSibling","patchProperty","proto","descriptor","defineProperty","patchProperties","descriptors","prefix","disallowedPatches","indexOf","patchExistingProperties","getOwnPropertyDescriptors","getOwnPropertyNames","forEach","assign","target","source","names","i","convertIntoANode","arg","convertNodesIntoANode","args","arguments","fragment","createDocumentFragment","appendChild","d","flushList","scheduled","enqueue","flush","didFlush","list","constructor","AsyncObserver","_scheduled","addedNodes","removedNodes","callbacks","Set","schedule","za","mutations","takeRecords","cb","observeChildren","Ba","sd","observer","add","_callback","_observer","_node","unobserveChildren","handle","delete","size","filterMutations","targetRootNode","map","mutation","mutationInScope","slice","filter","create","m","escapeAttrRegExp","escapeDataRegExp","escapeReplace","makeSet","arr","set","voidElements","plaintextParents","getInnerHTML","localName","s","c$","childNodes","child","nodeType","ELEMENT_NODE","tagName","attrs","attributes","attr","replace","h","TEXT_NODE","data","parentNode","COMMENT_NODE","console","error","nativeMethods","querySelector","selector","__shady_native_querySelector","querySelectorAll","__shady_native_querySelectorAll","nativeTree","installNativeAccessor","NATIVE_PREFIX","defineNativeAccessors","prop","copyProperties","nodeWalker","createTreeWalker","NodeFilter","SHOW_ALL","elementWalker","SHOW_ELEMENT","inertDoc","implementation","createHTMLDocument","clearNode","__shady_native_removeChild","ParentNodeAccessors","ParentNodeMethods","Sa","eventProps","EventTarget","__shady_native_addEventListener","Window","currentNode","lastChild","previousSibling","nextSibling","parentElement","DOCUMENT_FRAGMENT_NODE","textWalker","SHOW_TEXT","nextNode","nodeValue","__shady_native_insertBefore","HTMLElement","ParentNodeWalkerDescriptors","firstElementChild","lastElementChild","children","childElementCount","previousElementSibling","nextElementSibling","innerHTML","containerName","htmlContainer","namespaceURI","createElementNS","createElement","newContent","className","setAttribute","HTMLTemplateElement","DocumentFragment","InsideDescriptors","__shady_childNodes","__shady_lastChild","__shady_childElementCount","__shady_children","__shady_firstElementChild","__shady_lastElementChild","shadowRoot","__shady_shadowRoot","TextContentInnerHTMLDescriptors","__shady_textContent","__shady_innerHTML","OutsideDescriptors","__shady_parentElement","__shady_previousSibling","__shady_nextElementSibling","__shady_previousElementSibling","__shady_className","makeNonEnumerable","enumerable","noInstancePatching","patchOutsideElementAccessors","element","__outsideAccessors","patchInsideElementAccessors","__insideAccessors","customElements","polyfillWrapFlushCallback","eventWrappersName","Date","now","composedGetter","composedProp","Event","ev","supportsEventOptions","listener","supported","eventOptions","capture","addEventListener","removeEventListener","parseEventOptions","optionsOrCapture","once","passive","shadyTarget","__shadyTarget","nativeEventOptions","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","unpatchedEvents","DOMAttrModified","DOMAttributeNameChanged","DOMCharacterDataModified","DOMElementNameChanged","DOMNodeInserted","DOMNodeInsertedIntoDocument","DOMNodeRemoved","DOMNodeRemovedFromDocument","DOMSubtreeModified","getRootNodeWithFallback","eventTarget","__shady_getRootNode","pathComposer","startNode","composed","composedPath","current","startRoot","__shady_assignedSlot","host","event","__composedPath","retarget","refNode","path","refNodePath","ancestor","lastRoot","rootIdx","mixinComposedFlag","Base","klazz","type","options","__composed","__proto__","nonBubblingEventsToRetarget","hasRetargeted","__target","__relatedTarget","relatedTarget","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","shadyDispatchEvent","retargetedPath","bubbles","currentTarget","eventPhase","CAPTURING_PHASE","AT_TARGET","__propagationStopped","atTarget","BUBBLING_PHASE","findListener","wrappers","savedType","savedListener","savedCapture","savedOnce","savedPassive","savedNode","dispatchEvent","patchEvent","__shady_native_dispatchEvent","fnOrObj","handlerType","handleEvent","wrapperFn","__shady_removeEventListener","__previousCurrentTarget","stopImmediatePropagation","ret","lastCurrentTargetDesc","lastEventPhaseDesc","bubble","__shady_native_removeEventListener","idx","splice","activateFocusEventOverrides","EventPatchesDescriptors","EventPatches","isTrusted","__relatedTargetComposedPath","stopPropagation","getPrototypeOf","hasOwnProperty","SHADY_PROTO","patchedProto","SHADY_SOURCE_PROTO","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","patchClick","composedClickFn","cancelable","__shady_dispatchEvent","eventPropertyNamesForElement","substring","eventPropertyNamesForHTMLElement","wrappedDescriptorForEventProperty","property","shadyData","eventName","__onCallbackListeners","__shady_addEventListener","newSplice","addedCount","removed","calcSplices","currentEnd","old","oldEnd","currentStart","oldStart","prefixCount","suffixCount","minLength","min","currentValue","previousValue","index1","index2","count","equals","rowCount","columnCount","distances","j","north","west","edits","EDIT_ADD","EDIT_DELETE","northWest","EDIT_LEAVE","EDIT_UPDATE","reverse","splices","oldIndex","EventTargetPatches","scopingShim","getScopingShim","ShadyCSS","ScopingShim","scopeClassAttribute","setElementClass","removeShadyScoping","currentScopeName","unscopeNode","currentScopeIsCorrect","newScopeName","correctScope","currentScopeForNode","treeVisitor","visitorFn","nativeIsConnectedAccessors","nativeIsConnected","__shady_removeChild","removeOwnerShadyRoot","ownerShadyRoot","firstComposedNode","flattened","flattenedNodes","scheduleObserver","addedNode","removedNode","NodePatches","__shady_native_parentNode","__shady_native_lastChild","__shady_native_previousSibling","__shady_native_childNodes","childNodes.item","__shady_native_parentElement","isConnected","ownerDocument","tc","join","__shady_native_textContent","__shady_insertBefore","insertBefore","ref_node","refData","slotsAdded","ownerRoot","ownerShadyRootForNode","skipUnscoping","__noInsertionPoint","allowNativeInsert","needsScoping","needsSlotFinding","oldScopeName","scopeNode","_ensureSlotData","_pendingSlots","apply","$jscomp.arrayFromIterable","_asyncRender","recordInsertBefore","parentData","__shady_native_appendChild","adoptNode","removeChild","removingInsertionPoint","_removeContainedSlots","recordRemoveChild","changeSlotContent","preventNativeRemove","replaceChild","cloneNode","deep","__shady_native_cloneNode","ATTRIBUTE_NODE","nc","__shady_cloneNode","__shady_appendChild","SlotablePatches","assignedSlot","_render","query","matcher","halter","queryChildNodes","__shady_native_firstElementChild","__shady_native_lastElementChild","__shady_native_children","ParentNodePatches","Xb","append","prepend","replaceChildren","QueryPatches","useNative","o","ParentNodeDocumentOrFragmentPatches","ChildNodePatches","after","before","remove","replaceWith","distributeAttributeChange","_slotList","_validateSlots","oldName","__slotName","_nameForSlot","slots","_slotMap","_sortSlots","ElementPatches","__shady_native_previousElementSibling","__shady_native_nextElementSibling","slot","__shady_setAttribute","__shady_native_setAttribute","removeAttribute","__shady_native_removeAttribute","ElementShadowPatches","shadyUpgradeFragment","_init","recordChildNodes","ShadyRoot","ShadyRootConstructionToken","__CE_shadowRoot","publicRoot","ElementOrShadowRootPatches","__shady_native_innerHTML","HTMLElementPatches","shadowActive","activeElement","__shady_blur","__shady_native_blur","SlotPatches","assignedNodes","flatten","DocumentOrFragmentPatches","getElementById","id","getElInRoot","roots","el","elRoot","has","getAncestorRoots","docOrRoot","elementsFromPointProperty","DocumentOrShadowRootPatches","active","__shady_native_activeElement","activeRoot","elementsFromPoint","x","y","nativeResult","ancestorRoots","rootedResult","r","elementFromPoint","__shady_elementsFromPoint","DocumentPatches","importNode","__shady_native_importNode","__shady_importNode","WindowPatches","bind","NonStandardHTMLElement","patchMap","Text","Comment","CDATASection","ProcessingInstruction","HTMLSlotElement","CharacterData","disallowedNativePatches","applyPatchList","disallowed","patch","applyPatches","ctor","PROTO_IS_PATCHED","PATCHED_PROTO","patchElementProto","patchNode","nativeProto","setPrototypeOf","OutsideAccessors","InsideAcccessors","linkNode","containerData","ref_nodeData","psd","nsd","first","adoptedParent","previous","ShadowRootPatches","patchShadyAccessors","isRendering","deferConnectionCallbacks","readyState","rootRendered","ancestorList","ancestors","unshift","token","TypeError","mode","hostData","MODE_CLOSED","rootData","_renderPending","renderRoot","__childSlotCount","_renderSelf","ic","wasRendering","_distribute","slotData","n$","_previouslyAssignedNodes","_prevAssignedSlot","_distributeNodeToSlot","slotParentRoot","slotParentData","_addAssignedToFlattenedNodes","prevAssignedNodes","dirty","_fireSlotChange","_compose","composeList","targetNode","distributedNode","_hasRendered","forcedSlot","oldSlot","__shady_slot","CATCHALL_NAME","assigned","nestedAssigned","slotNamesToSort","slotParent","_mapSlots","sort","listA","listB","nA","nB","didRemove","patchShadyRoot","SHADY_PREFIX","defineProperties","nodeName","define","connectMap","Map","v","k","clear","__shadydom_connectedCallback","__shadydom_disconnectedCallback","ManageConnect","base","connected","disconnected","counter","connectFlag","connectedCallback","disconnectedCallback","originalDefine","CustomElementRegistry","Wrapper","?.prototype","__shady_replaceChild","__shady_contains","__shady_native_getAttribute","__shady_removeAttribute","__shady_attachShadow","__shady_native_focus","DOCUMENT_NODE","__shady_getElementById","__shady_elementFromPoint","__shady_querySelector","__shady_querySelectorAll","__shady_assignedNodes","__shady_append","__shady_prepend","__shady_after","__shady_before","__shady_remove","__shady_replaceWith","$jscomp.global.Object.defineProperties","_activeElement","__shady_isConnected","addEventPropertyWrapper","wrapperMap","WeakMap","wrap","wrapper","flushInitial","handlesDynamicScoping","wrapIfNeeded","addNativePrefixedProperties"],"sources":["/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/shady-data.js"," [synthetic:es6/util/arrayiterator] "," [synthetic:es6/util/makeiterator] "," [synthetic:es6/util/arrayfromiterable] "," [synthetic:es6/util/arrayfromiterator] "," [synthetic:util/global] ","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/utils.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patch-native.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/flush.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/observe-changes.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/innerHTML.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patch-instances.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patch-events.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/array-splice.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/EventTarget.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/style-scoping.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/Node.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/attach-shadow.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/Slotable.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/ParentNode.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/ChildNode.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/Element.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/ElementOrShadowRoot.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/HTMLElement.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/Slot.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/DocumentOrFragment.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/DocumentOrShadowRoot.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/Document.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/Window.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patch-prototypes.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/link-nodes.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patches/ShadowRoot.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/patch-shadyRoot.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/wrapper.js","/Users/hitansh/Documents/wallet-web-integration-app/node_modules/@webcomponents/shadydom/src/shadydom.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport class ShadyData {\n  /** @override */\n  toJSON() {\n    return {};\n  }\n}\n\nexport function ensureShadyDataForNode(node) {\n  if (!node.__shady) {\n    node.__shady = new ShadyData();\n  }\n  return node.__shady;\n}\n\nexport function shadyDataForNode(node) {\n  return node && node.__shady;\n}\n","","","","","","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport {shadyDataForNode} from './shady-data.js';\n\n/** @type {!Object} */\nexport const settings = window['ShadyDOM'] || {};\n\nsettings.hasNativeShadowDOM = Boolean(\n  Element.prototype.attachShadow && Node.prototype.getRootNode\n);\n\n// The user might need to pass the custom elements polyfill a flag by setting an\n// object to `customElements`, so check for `customElements.define` also.\nexport const hasCustomElements = () =>\n  Boolean(window.customElements && window.customElements.define);\n// The custom elements polyfill is typically loaded after Shady DOM, so this\n// check isn't reliable during initial evaluation. However, because the\n// polyfills are loaded immediately after one another, it works at runtime.\nexport const hasPolyfilledCustomElements = () =>\n  Boolean(\n    window.customElements && window.customElements['polyfillWrapFlushCallback']\n  );\n\nconst desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');\n\nsettings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);\nsettings.inUse = settings['force'] || !settings.hasNativeShadowDOM;\nsettings.noPatch = /** @type {string|boolean} */ (settings['noPatch'] || false);\n// eslint-disable-next-line no-self-assign\nsettings.preferPerformance = settings['preferPerformance'];\nsettings.patchOnDemand = settings.noPatch === 'on-demand';\n\nconst IS_IE = navigator.userAgent.match('Trident');\nsettings.IS_IE = IS_IE;\n\n// Helper for prefixed properties.\nexport const getPropertyName = (obj, name) => {\n  const prefixed = `ms${name[0].toUpperCase() + name.slice(1)}`;\n  return obj[prefixed] ? prefixed : name;\n};\n\nexport const canUpgrade = () => !settings.IS_IE;\n\nexport const isTrackingLogicalChildNodes = (node) => {\n  const nodeData = shadyDataForNode(node);\n  return nodeData && nodeData.firstChild !== undefined;\n};\n\nexport const isShadyRoot = (obj) => obj instanceof ShadowRoot;\n\nexport const hasShadowRootWithSlot = (node) => {\n  const nodeData = shadyDataForNode(node);\n  let root = nodeData && nodeData.root;\n  return root && root._hasInsertionPoint();\n};\n\nlet p = Element.prototype;\nlet matches =\n  p.matches ||\n  p.matchesSelector ||\n  p.mozMatchesSelector ||\n  p.msMatchesSelector ||\n  p.oMatchesSelector ||\n  p.webkitMatchesSelector;\n\nexport const matchesSelector = (element, selector) => {\n  return matches.call(element, selector);\n};\n\nexport const mixin = (target, source) => {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n  return target;\n};\n\n// NOTE, prefer MutationObserver over Promise for microtask timing\n// for consistency x-platform.\nlet twiddle = document.createTextNode('');\nlet content = 0;\nlet queue = [];\nnew MutationObserver(() => {\n  while (queue.length) {\n    // catch errors in user code...\n    try {\n      queue.shift()();\n    } catch (e) {\n      // enqueue another record and throw\n      twiddle.textContent = content++;\n      throw e;\n    }\n  }\n}).observe(twiddle, {characterData: true});\n\n// use MutationObserver to get microtask async timing.\nexport const microtask = (callback) => {\n  queue.push(callback);\n  twiddle.textContent = content++;\n};\n\n/** @type {function(!Document, !Node): boolean} */\nexport const documentContains = (() => {\n  if (document.contains) {\n    return (doc, node) => doc[NATIVE_PREFIX + 'contains'](node);\n  } else {\n    return (doc, node) =>\n      doc === node ||\n      (doc.documentElement &&\n        doc.documentElement[NATIVE_PREFIX + 'contains'](node));\n  }\n})();\n\nexport const contains = (container, node) => {\n  while (node) {\n    if (node == container) {\n      return true;\n    }\n    node = node[SHADY_PREFIX + 'parentNode'];\n  }\n  return false;\n};\n\nconst getNodeHTMLCollectionName = (node) =>\n  node.getAttribute('id') || node.getAttribute('name');\n\nconst isValidHTMLCollectionName = (name) => name !== 'length' && isNaN(name);\n\nexport const createPolyfilledHTMLCollection = (nodes) => {\n  // Note: loop in reverse so that the first named item matches the named property\n  for (let l = nodes.length - 1; l >= 0; l--) {\n    const node = nodes[l];\n    const name = getNodeHTMLCollectionName(node);\n\n    if (name && isValidHTMLCollectionName(name)) {\n      nodes[name] = node;\n    }\n  }\n  nodes.item = function (index) {\n    return nodes[index];\n  };\n  nodes.namedItem = function (name) {\n    if (isValidHTMLCollectionName(name) && nodes[name]) {\n      return nodes[name];\n    }\n\n    for (const node of nodes) {\n      const nodeName = getNodeHTMLCollectionName(node);\n\n      if (nodeName == name) {\n        return node;\n      }\n    }\n\n    return null;\n  };\n  return nodes;\n};\n\nexport const NATIVE_PREFIX = '__shady_native_';\nexport const SHADY_PREFIX = '__shady_';\n\nexport const nativeChildNodesArray = (parent) => {\n  const result = [];\n  for (\n    let n = parent[NATIVE_PREFIX + 'firstChild'];\n    n;\n    n = n[NATIVE_PREFIX + 'nextSibling']\n  ) {\n    result.push(n);\n  }\n  return result;\n};\n\nexport const childNodesArray = (parent) => {\n  const result = [];\n  for (\n    let n = parent[SHADY_PREFIX + 'firstChild'];\n    n;\n    n = n[SHADY_PREFIX + 'nextSibling']\n  ) {\n    result.push(n);\n  }\n  return result;\n};\n\nconst patchProperty = (proto, name, descriptor) => {\n  descriptor.configurable = true;\n  // NOTE: we prefer writing directly because some browsers\n  // have descriptors that are writable but not configurable (e.g.\n  // `appendChild` on older browsers)\n  if (descriptor.value) {\n    proto[name] = descriptor.value;\n  } else {\n    try {\n      Object.defineProperty(proto, name, descriptor);\n    } catch (e) {\n      // this error is harmless so we just trap it.\n    }\n  }\n};\n\n/**\n * Patch a group of accessors on an object. By default this overrides\n * @param {!Object} proto\n * @param {!Object} descriptors\n * @param {string=} prefix\n * @param {Array=} disallowedPatches\n */\nexport const patchProperties = (\n  proto,\n  descriptors,\n  prefix = '',\n  disallowedPatches\n) => {\n  for (let name in descriptors) {\n    if (disallowedPatches && disallowedPatches.indexOf(name) >= 0) {\n      continue;\n    }\n    patchProperty(proto, prefix + name, descriptors[name]);\n  }\n};\n\nexport const patchExistingProperties = (proto, descriptors) => {\n  for (let name in descriptors) {\n    if (name in proto) {\n      patchProperty(proto, name, descriptors[name]);\n    }\n  }\n};\n\n// note, this is not a perfect polyfill since it doesn't include symbols\n/** @return {!Object<!ObjectPropertyDescriptor>} */\nexport const getOwnPropertyDescriptors = (obj) => {\n  const descriptors = {};\n  Object.getOwnPropertyNames(obj).forEach((name) => {\n    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n  });\n  return descriptors;\n};\n\nexport const assign = (target, source) => {\n  const names = Object.getOwnPropertyNames(source);\n  for (let i = 0, p; i < names.length; i++) {\n    p = names[i];\n    target[p] = source[p];\n  }\n};\n\nexport const arrayFrom = (object) => {\n  return [].slice.call(/** @type {IArrayLike} */ (object));\n};\n\n/**\n * Converts a single value to a node for `convertNodesIntoANode`.\n *\n * @param {*} arg\n * @return {!Node}\n */\nconst convertIntoANode = (arg) => {\n  // `\"\" + arg` is used to implicitly coerce the value to a string (coercing a\n  // symbol *should* fail here) before passing to `createTextNode`, which has\n  // argument type `(number|string)`.\n  return !(arg instanceof Node) ? document.createTextNode('' + arg) : arg;\n};\n\n/**\n * Implements 'convert nodes into a node'. The spec text indicates that strings\n * become text nodes, but doesn't describe what should happen if a non-Node,\n * non-string value is found in the arguments list. In practice, browsers coerce\n * these values to strings and convert those to text nodes.\n * https://dom.spec.whatwg.org/#converting-nodes-into-a-node\n *\n * @param {...*} args\n * @return {!Node}\n */\nexport const convertNodesIntoANode = (...args) => {\n  if (args.length === 1) {\n    return convertIntoANode(args[0]);\n  }\n\n  const fragment = document.createDocumentFragment();\n  for (const arg of args) {\n    fragment.appendChild(convertIntoANode(arg));\n  }\n  return fragment;\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport * as utils from './utils.js';\nimport {patchProperties} from './utils.js';\nimport {getInnerHTML} from './innerHTML.js';\n\nconst hasDescriptors = utils.settings.hasDescriptors;\nexport const NATIVE_PREFIX = utils.NATIVE_PREFIX;\n\n// Object on which raw native methods are stored.\n// e.g. `nativeMethods.querySelector.call(node, selector)`\n// same as `node.querySelector(selector)`\nexport const nativeMethods = {\n  /** @this {Element} */\n  querySelector(selector) {\n    return this[NATIVE_PREFIX + 'querySelector'](selector);\n  },\n  /** @this {Element} */\n  querySelectorAll(selector) {\n    return this[NATIVE_PREFIX + 'querySelectorAll'](selector);\n  },\n};\n// Object on which raw native accessors are available via `accessorName(node)`.\n// e.g. `nativeTree.firstChild(node)`\n// same as `node.firstChild`\nexport const nativeTree = {};\n\nconst installNativeAccessor = (name) => {\n  nativeTree[name] = (node) => node[NATIVE_PREFIX + name];\n};\n\nconst installNativeMethod = (name, fn) => {\n  if (!nativeMethods[name]) {\n    nativeMethods[name] = fn;\n  }\n};\n\nconst defineNativeAccessors = (proto, descriptors) => {\n  patchProperties(proto, descriptors, NATIVE_PREFIX);\n  // make native accessors available to users\n  for (let prop in descriptors) {\n    installNativeAccessor(prop);\n  }\n};\n\nconst copyProperties = (proto, list = []) => {\n  for (let i = 0; i < list.length; i++) {\n    const name = list[i];\n    const descriptor = Object.getOwnPropertyDescriptor(proto, name);\n    if (descriptor) {\n      Object.defineProperty(proto, NATIVE_PREFIX + name, descriptor);\n      // make native methods/accessors available to users\n      if (descriptor.value) {\n        installNativeMethod(name, descriptor.value);\n      } else {\n        installNativeAccessor(name);\n      }\n    }\n  }\n};\n\n/** @type {!TreeWalker} */\nconst nodeWalker = document.createTreeWalker(\n  document,\n  NodeFilter.SHOW_ALL,\n  null,\n  false\n);\n\n/** @type {!TreeWalker} */\nconst elementWalker = document.createTreeWalker(\n  document,\n  NodeFilter.SHOW_ELEMENT,\n  null,\n  false\n);\n\n/** @type {!Document} */\nconst inertDoc = document.implementation.createHTMLDocument('inert');\n\nconst clearNode = (node) => {\n  let firstChild;\n  while ((firstChild = node[NATIVE_PREFIX + 'firstChild'])) {\n    node[NATIVE_PREFIX + 'removeChild'](firstChild);\n  }\n};\n\nconst ParentNodeAccessors = [\n  'firstElementChild',\n  'lastElementChild',\n  'children',\n  'childElementCount',\n];\n\nconst ParentNodeMethods = [\n  'querySelector',\n  'querySelectorAll',\n  'append',\n  'prepend',\n  'replaceChildren',\n];\n\nexport const addNativePrefixedProperties = () => {\n  // EventTarget\n  const eventProps = [\n    'dispatchEvent',\n    'addEventListener',\n    'removeEventListener',\n  ];\n  if (window.EventTarget) {\n    copyProperties(window.EventTarget.prototype, eventProps);\n\n    // In Firefox 31, `EventTarget` exists, but `EventTarget.prototype` is not\n    // in the prototype chain of `window` and, strangely,\n    // `window instanceof EventTarget` still returns true.\n    if (window[NATIVE_PREFIX + 'addEventListener'] === undefined) {\n      copyProperties(Window.prototype, eventProps);\n    }\n  } else {\n    copyProperties(Node.prototype, eventProps);\n    copyProperties(Window.prototype, eventProps);\n  }\n\n  // Node\n  if (hasDescriptors) {\n    copyProperties(Node.prototype, [\n      'parentNode',\n      'firstChild',\n      'lastChild',\n      'previousSibling',\n      'nextSibling',\n      'childNodes',\n      'parentElement',\n      'textContent',\n    ]);\n  } else {\n    defineNativeAccessors(Node.prototype, {\n      parentNode: {\n        /** @this {Node} */\n        get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.parentNode();\n        },\n      },\n      firstChild: {\n        /** @this {Node} */\n        get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.firstChild();\n        },\n      },\n      lastChild: {\n        /** @this {Node} */\n        get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.lastChild();\n        },\n      },\n      previousSibling: {\n        /** @this {Node} */\n        get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.previousSibling();\n        },\n      },\n      nextSibling: {\n        /** @this {Node} */\n        get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.nextSibling();\n        },\n      },\n      // TODO(sorvell): make this a NodeList or whatever\n      childNodes: {\n        /** @this {Node} */\n        get() {\n          const nodes = [];\n          nodeWalker.currentNode = this;\n          let n = nodeWalker.firstChild();\n          while (n) {\n            nodes.push(n);\n            n = nodeWalker.nextSibling();\n          }\n          return nodes;\n        },\n      },\n      parentElement: {\n        /** @this {Node} */\n        get() {\n          elementWalker.currentNode = this;\n          return elementWalker.parentNode();\n        },\n      },\n      textContent: {\n        /** @this {Node} */\n        get() {\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              // TODO(sorvell): This cannot be a single TreeWalker that's reused\n              // at least for Safari 9, but it's unclear why.\n              // eslint-disable-next-line no-case-declarations\n              const textWalker = document.createTreeWalker(\n                this,\n                NodeFilter.SHOW_TEXT,\n                null,\n                false\n              );\n              // eslint-disable-next-line no-case-declarations\n              let content = '',\n                n;\n              while ((n = textWalker.nextNode())) {\n                // TODO(sorvell): can't use textContent since we patch it on Node.prototype!\n                // However, should probably patch it only on element.\n                content += n.nodeValue;\n              }\n              return content;\n            default:\n              return this.nodeValue;\n          }\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n        /** @this {Node} */\n        set(value) {\n          if (typeof value === 'undefined' || value === null) {\n            value = '';\n          }\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              clearNode(this);\n              // Document fragments must have no childnodes if setting a blank string\n              if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n                // Note: old Chrome versions require 2nd argument here\n                this[NATIVE_PREFIX + 'insertBefore'](\n                  document.createTextNode(value),\n                  undefined\n                );\n              }\n              break;\n            default:\n              // TODO(sorvell): can't do this if patch nodeValue.\n              this.nodeValue = value;\n              break;\n          }\n        },\n      },\n    });\n  }\n\n  copyProperties(Node.prototype, [\n    'appendChild',\n    'insertBefore',\n    'removeChild',\n    'replaceChild',\n    'cloneNode',\n    'contains',\n  ]);\n\n  // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement\n  copyProperties(HTMLElement.prototype, ['parentElement', 'contains']);\n\n  const ParentNodeWalkerDescriptors = {\n    firstElementChild: {\n      /** @this {ParentNode} */\n      get() {\n        elementWalker.currentNode = this;\n        return elementWalker.firstChild();\n      },\n    },\n    lastElementChild: {\n      /** @this {ParentNode} */\n      get() {\n        elementWalker.currentNode = this;\n        return elementWalker.lastChild();\n      },\n    },\n    children: {\n      /** @this {ParentNode} */\n      get() {\n        let nodes = [];\n        elementWalker.currentNode = this;\n        let n = elementWalker.firstChild();\n        while (n) {\n          nodes.push(n);\n          n = elementWalker.nextSibling();\n        }\n        return utils.createPolyfilledHTMLCollection(nodes);\n      },\n    },\n    childElementCount: {\n      /** @this {ParentNode} */\n      get() {\n        if (this.children) {\n          return this.children.length;\n        }\n        return 0;\n      },\n    },\n  };\n\n  // Element\n  if (hasDescriptors) {\n    copyProperties(Element.prototype, ParentNodeAccessors);\n\n    copyProperties(Element.prototype, [\n      'previousElementSibling',\n      'nextElementSibling',\n      'innerHTML',\n      'className',\n    ]);\n\n    // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement\n    copyProperties(HTMLElement.prototype, [\n      'children',\n      'innerHTML',\n      'className',\n    ]);\n  } else {\n    defineNativeAccessors(Element.prototype, ParentNodeWalkerDescriptors);\n    defineNativeAccessors(Element.prototype, {\n      previousElementSibling: {\n        /** @this {Element} */\n        get() {\n          elementWalker.currentNode = this;\n          return elementWalker.previousSibling();\n        },\n      },\n      nextElementSibling: {\n        /** @this {Element} */\n        get() {\n          elementWalker.currentNode = this;\n          return elementWalker.nextSibling();\n        },\n      },\n      innerHTML: {\n        /** @this {Element} */\n        get() {\n          return getInnerHTML(this, utils.nativeChildNodesArray);\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n        /** @this {Element} */\n        set(value) {\n          const content =\n            this.localName === 'template'\n              ? /** @type {HTMLTemplateElement} */ (this).content\n              : this;\n          clearNode(content);\n          const containerName = this.localName || 'div';\n          let htmlContainer;\n          if (\n            !this.namespaceURI ||\n            this.namespaceURI === inertDoc.namespaceURI\n          ) {\n            htmlContainer = inertDoc.createElement(containerName);\n          } else {\n            htmlContainer = inertDoc.createElementNS(\n              this.namespaceURI,\n              containerName\n            );\n          }\n          htmlContainer.innerHTML = value;\n          const newContent =\n            this.localName === 'template'\n              ? /** @type {HTMLTemplateElement} */ (htmlContainer).content\n              : htmlContainer;\n          let firstChild;\n          while ((firstChild = newContent[NATIVE_PREFIX + 'firstChild'])) {\n            // Note: old Chrome versions require 2nd argument here\n            content[NATIVE_PREFIX + 'insertBefore'](firstChild, undefined);\n          }\n        },\n      },\n      className: {\n        /** @this {Element} */\n        get() {\n          return this.getAttribute('class') || '';\n        },\n        /** @this {Element} */\n        set(value) {\n          this.setAttribute('class', value);\n        },\n      },\n    });\n  }\n\n  copyProperties(Element.prototype, [\n    'setAttribute',\n    'getAttribute',\n    'hasAttribute',\n    'removeAttribute',\n    // on older Safari, these are on Element.\n    'focus',\n    'blur',\n  ]);\n  copyProperties(Element.prototype, ParentNodeMethods);\n\n  // HTMLElement\n  copyProperties(HTMLElement.prototype, ['focus', 'blur']);\n\n  // HTMLTemplateElement\n  if (window.HTMLTemplateElement) {\n    copyProperties(window.HTMLTemplateElement.prototype, ['innerHTML']);\n  }\n\n  // DocumentFragment\n  if (hasDescriptors) {\n    // NOTE, IE 11 does not have on DocumentFragment\n    // firstElementChild\n    // lastElementChild\n    copyProperties(DocumentFragment.prototype, ParentNodeAccessors);\n  } else {\n    defineNativeAccessors(\n      DocumentFragment.prototype,\n      ParentNodeWalkerDescriptors\n    );\n  }\n\n  copyProperties(DocumentFragment.prototype, ParentNodeMethods);\n\n  // Document\n  if (hasDescriptors) {\n    copyProperties(Document.prototype, ParentNodeAccessors);\n    copyProperties(Document.prototype, ['activeElement']);\n  } else {\n    defineNativeAccessors(Document.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(Document.prototype, [\n    'importNode',\n    'getElementById',\n    'elementFromPoint',\n    utils.getPropertyName(Document.prototype, 'elementsFromPoint'),\n  ]);\n  copyProperties(Document.prototype, ParentNodeMethods);\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\n\n// render enqueuer/flusher\nlet flushList = [];\nlet scheduled;\nexport function enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    utils.microtask(flush);\n  }\n  flushList.push(callback);\n}\n\nexport function flush() {\n  scheduled = false;\n  let didFlush = Boolean(flushList.length);\n  while (flushList.length) {\n    flushList.shift()();\n  }\n  return didFlush;\n}\n\nflush['list'] = flushList;\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {ensureShadyDataForNode} from './shady-data.js';\n\nclass AsyncObserver {\n  constructor() {\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      utils.microtask(() => {\n        this.flush();\n      });\n    }\n  }\n\n  flush() {\n    if (this._scheduled) {\n      this._scheduled = false;\n      let mutations = this.takeRecords();\n      if (mutations.length) {\n        this.callbacks.forEach(function (cb) {\n          cb(mutations);\n        });\n      }\n    }\n  }\n\n  takeRecords() {\n    if (this.addedNodes.length || this.removedNodes.length) {\n      let mutations = [\n        {\n          addedNodes: this.addedNodes,\n          removedNodes: this.removedNodes,\n        },\n      ];\n      this.addedNodes = [];\n      this.removedNodes = [];\n      return mutations;\n    }\n    return [];\n  }\n}\n\n// TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\nexport let observeChildren = function (node, callback) {\n  const sd = ensureShadyDataForNode(node);\n  if (!sd.observer) {\n    sd.observer = new AsyncObserver();\n  }\n  sd.observer.callbacks.add(callback);\n  let observer = sd.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords() {\n      return observer.takeRecords();\n    },\n  };\n};\n\nexport let unobserveChildren = function (handle) {\n  let observer = handle && handle._observer;\n  if (observer) {\n    observer.callbacks.delete(handle._callback);\n    if (!observer.callbacks.size) {\n      ensureShadyDataForNode(handle._node).observer = null;\n    }\n  }\n};\n\nexport function filterMutations(mutations, target) {\n  /** @const {Node} */\n  const targetRootNode = target.getRootNode();\n  return mutations\n    .map(function (mutation) {\n      /** @const {boolean} */\n      const mutationInScope = targetRootNode === mutation.target.getRootNode();\n      if (mutationInScope && mutation.addedNodes) {\n        let nodes = utils.arrayFrom(mutation.addedNodes).filter(function (n) {\n          return targetRootNode === n.getRootNode();\n        });\n        if (nodes.length) {\n          mutation = Object.create(mutation);\n          Object.defineProperty(mutation, 'addedNodes', {\n            value: nodes,\n            configurable: true,\n          });\n          return mutation;\n        }\n      } else if (mutationInScope) {\n        return mutation;\n      }\n    })\n    .filter(function (m) {\n      return m;\n    });\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nlet escapeAttrRegExp = /[&\\u00A0\"]/g;\nlet escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n    case '<':\n      return '&lt;';\n    case '>':\n      return '&gt;';\n    case '\"':\n      return '&quot;';\n    case '\\u00A0':\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  let set = {};\n  for (let i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n  return set;\n}\n\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\nlet voidElements = makeSet([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n]);\n\nlet plaintextParents = makeSet([\n  'style',\n  'script',\n  'xmp',\n  'iframe',\n  'noembed',\n  'noframes',\n  'plaintext',\n  'noscript',\n]);\n\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @param {Function=} callback\n */\nexport function getOuterHTML(node, parentNode, callback) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE: {\n      let tagName = node.localName;\n      let s = '<' + tagName;\n      let attrs = node.attributes;\n      for (let i = 0, attr; (attr = attrs[i]); i++) {\n        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n      }\n      s += '>';\n      if (voidElements[tagName]) {\n        return s;\n      }\n      return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n    }\n    case Node.TEXT_NODE: {\n      let data = /** @type {Text} */ (node).data;\n      if (parentNode && plaintextParents[parentNode.localName]) {\n        return data;\n      }\n      return escapeData(data);\n    }\n    case Node.COMMENT_NODE: {\n      return '<!--' + /** @type {Comment} */ (node).data + '-->';\n    }\n    default: {\n      window.console.error(node);\n      throw new Error('not implemented');\n    }\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Function=} callback\n */\nexport function getInnerHTML(node, callback) {\n  if (node.localName === 'template') {\n    node = /** @type {HTMLTemplateElement} */ (node).content;\n  }\n  let s = '';\n  let c$ = callback ? callback(node) : node.childNodes;\n  for (let i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\n    s += getOuterHTML(child, node, callback);\n  }\n  return s;\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {ensureShadyDataForNode} from './shady-data.js';\n\nexport const InsideDescriptors = utils.getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get childNodes() {\n    return this[utils.SHADY_PREFIX + 'childNodes'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    return this[utils.SHADY_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    return this[utils.SHADY_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get childElementCount() {\n    return this[utils.SHADY_PREFIX + 'childElementCount'];\n  },\n\n  /** @this {Node} */\n  get children() {\n    return this[utils.SHADY_PREFIX + 'children'];\n  },\n\n  /** @this {Node} */\n  get firstElementChild() {\n    return this[utils.SHADY_PREFIX + 'firstElementChild'];\n  },\n\n  /** @this {Node} */\n  get lastElementChild() {\n    return this[utils.SHADY_PREFIX + 'lastElementChild'];\n  },\n\n  /** @this {Node} */\n  get shadowRoot() {\n    return this[utils.SHADY_PREFIX + 'shadowRoot'];\n  },\n});\n\nexport const TextContentInnerHTMLDescriptors = utils.getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get textContent() {\n    return this[utils.SHADY_PREFIX + 'textContent'];\n  },\n\n  /** @this {Node} */\n  set textContent(value) {\n    this[utils.SHADY_PREFIX + 'textContent'] = value;\n  },\n\n  /** @this {Node} */\n  get innerHTML() {\n    return this[utils.SHADY_PREFIX + 'innerHTML'];\n  },\n\n  /** @this {Node} */\n  set innerHTML(value) {\n    this[utils.SHADY_PREFIX + 'innerHTML'] = value;\n  },\n});\n\nexport const OutsideDescriptors = utils.getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentElement() {\n    return this[utils.SHADY_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get parentNode() {\n    return this[utils.SHADY_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    return this[utils.SHADY_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    return this[utils.SHADY_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get nextElementSibling() {\n    return this[utils.SHADY_PREFIX + 'nextElementSibling'];\n  },\n\n  /** @this {Node} */\n  get previousElementSibling() {\n    return this[utils.SHADY_PREFIX + 'previousElementSibling'];\n  },\n\n  /** @this {Node} */\n  get className() {\n    return this[utils.SHADY_PREFIX + 'className'];\n  },\n\n  /** @this {Node} */\n  set className(value) {\n    this[utils.SHADY_PREFIX + 'className'] = value;\n  },\n});\n\nconst makeNonEnumerable = (descriptors) => {\n  for (let prop in descriptors) {\n    const descriptor = descriptors[prop];\n    // NOTE, the only known reason the descriptor wouldn't exist here is\n    // if someone has patched `Object.getOwnPropertyNames`, but we've seen this\n    // so this is just to be extra safe.\n    if (descriptor) {\n      descriptor.enumerable = false;\n    }\n  }\n};\n\nmakeNonEnumerable(InsideDescriptors);\nmakeNonEnumerable(TextContentInnerHTMLDescriptors);\nmakeNonEnumerable(OutsideDescriptors);\n\nconst noInstancePatching =\n  utils.settings.hasDescriptors || utils.settings.noPatch === true;\n\n// ensure an element has patched \"outside\" accessors; no-op when not needed\nexport let patchOutsideElementAccessors = noInstancePatching\n  ? function () {}\n  : function (element) {\n      const sd = ensureShadyDataForNode(element);\n      if (!sd.__outsideAccessors) {\n        sd.__outsideAccessors = true;\n        utils.patchExistingProperties(element, OutsideDescriptors);\n      }\n    };\n\n// ensure an element has patched \"inside\" accessors; no-op when not needed\nexport let patchInsideElementAccessors = noInstancePatching\n  ? function () {}\n  : function (element) {\n      const sd = ensureShadyDataForNode(element);\n      if (!sd.__insideAccessors) {\n        sd.__insideAccessors = true;\n        utils.patchExistingProperties(element, InsideDescriptors);\n        // NOTE: There are compatibility issues with patches for `textContent`\n        // and `innerHTML` between CE and SD. Since SD patches are applied\n        // via `ShadyDOM.patch` and CE patches are applied as the tree is walked,\n        // SD patches overwrite CE patches.\n        // * When SD is in patching mode, SD calls through to native\n        // methods not patched by CE (since SD is at the bottom) and CE does not\n        // upgrade, connect, or disconnect elements. Therefore do *not patch*\n        // these accessors in this case.\n        // * When SD is in `noPatch` mode, the SD patches call through to\n        // \"native\" methods that are patched by CE (since CE is at the bottom).\n        // Therefore continue to patch in this case.\n        // If the custom elements polyfill is not loaded, then these accessors\n        // should be patched so they work correctly.\n        if (!utils.hasPolyfilledCustomElements() || utils.settings.noPatch) {\n          utils.patchExistingProperties(\n            element,\n            TextContentInnerHTMLDescriptors\n          );\n        }\n      }\n    };\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {flush} from './flush.js';\nimport {shadyDataForNode, ensureShadyDataForNode} from './shady-data.js';\n\n/*\nMake this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`\nhttps://github.com/webcomponents/shadydom/issues/173\n*/\nconst /** string */ eventWrappersName = `__eventWrappers${Date.now()}`;\n\n/** @type {?function(!Event): boolean} */\nconst composedGetter = (() => {\n  const composedProp = Object.getOwnPropertyDescriptor(\n    Event.prototype,\n    'composed'\n  );\n  return composedProp ? (ev) => composedProp.get.call(ev) : null;\n})();\n\nconst supportsEventOptions = (() => {\n  let supported = false;\n  let eventOptions = {\n    get capture() {\n      supported = true;\n      return false;\n    },\n  };\n  const listener = () => {};\n  // NOTE: These will be unpatched at this point.\n  window.addEventListener('test', listener, eventOptions);\n  window.removeEventListener('test', listener, eventOptions);\n  return supported;\n})();\n\nconst parseEventOptions = (optionsOrCapture) => {\n  let capture, once, passive, shadyTarget;\n  if (optionsOrCapture && typeof optionsOrCapture === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n    shadyTarget = optionsOrCapture.__shadyTarget;\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n  return {\n    shadyTarget,\n    capture,\n    once,\n    passive,\n    nativeEventOptions: supportsEventOptions ? optionsOrCapture : capture,\n  };\n};\n\n// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\nconst alwaysComposed = {\n  'blur': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'click': true,\n  'dblclick': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'wheel': true,\n  'beforeinput': true,\n  'input': true,\n  'keydown': true,\n  'keyup': true,\n  'compositionstart': true,\n  'compositionupdate': true,\n  'compositionend': true,\n  'touchstart': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchcancel': true,\n  'pointerover': true,\n  'pointerenter': true,\n  'pointerdown': true,\n  'pointermove': true,\n  'pointerup': true,\n  'pointercancel': true,\n  'pointerout': true,\n  'pointerleave': true,\n  'gotpointercapture': true,\n  'lostpointercapture': true,\n  'dragstart': true,\n  'drag': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'drop': true,\n  'dragend': true,\n  'DOMActivate': true,\n  'DOMFocusIn': true,\n  'DOMFocusOut': true,\n  'keypress': true,\n};\n\nconst unpatchedEvents = {\n  'DOMAttrModified': true,\n  'DOMAttributeNameChanged': true,\n  'DOMCharacterDataModified': true,\n  'DOMElementNameChanged': true,\n  'DOMNodeInserted': true,\n  'DOMNodeInsertedIntoDocument': true,\n  'DOMNodeRemoved': true,\n  'DOMNodeRemovedFromDocument': true,\n  'DOMSubtreeModified': true,\n};\n\n/**\n * Some EventTarget subclasses are not Node subclasses, and you cannot call\n * `getRootNode()` on them.\n *\n * @param {!(Node|EventTarget)} eventTarget\n * @return {!(Node|EventTarget)}\n */\nfunction getRootNodeWithFallback(eventTarget) {\n  if (eventTarget instanceof Node) {\n    return eventTarget[utils.SHADY_PREFIX + 'getRootNode']();\n  } else {\n    return eventTarget;\n  }\n}\n\nfunction pathComposer(startNode, composed) {\n  let composedPath = [];\n  let current = startNode;\n  let startRoot = getRootNodeWithFallback(startNode);\n  while (current) {\n    composedPath.push(current);\n    if (current[utils.SHADY_PREFIX + 'assignedSlot']) {\n      current = current[utils.SHADY_PREFIX + 'assignedSlot'];\n    } else if (\n      current.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n      current.host &&\n      (composed || current !== startRoot)\n    ) {\n      current = current.host;\n    } else {\n      current = current[utils.SHADY_PREFIX + 'parentNode'];\n    }\n  }\n  // event composedPath includes window when startNode's ownerRoot is document\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n  return composedPath;\n}\n\nexport const composedPath = (event) => {\n  if (!event.__composedPath) {\n    event.__composedPath = pathComposer(event.target, true);\n  }\n  return event.__composedPath;\n};\n\nfunction retarget(refNode, path) {\n  if (!utils.isShadyRoot) {\n    return refNode;\n  }\n  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n  let refNodePath = pathComposer(refNode, true);\n  let p$ = path;\n  for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = getRootNodeWithFallback(ancestor);\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n    if (!utils.isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nlet EventPatches = {\n  /**\n   * @this {Event}\n   */\n  get composed() {\n    if (this.__composed === undefined) {\n      // if there's an original `composed` getter on the Event prototype, use that\n      if (composedGetter) {\n        // TODO(web-padawan): see https://github.com/webcomponents/shadydom/issues/275\n        this.__composed =\n          this.type === 'focusin' ||\n          this.type === 'focusout' ||\n          composedGetter(this);\n        // If the event is trusted, or `isTrusted` is not supported, check the list of always composed events\n      } else if (this.isTrusted !== false) {\n        this.__composed = alwaysComposed[this.type];\n      }\n    }\n    return /** @type {!Event} */ (this).__composed || false;\n  },\n\n  /**\n   * @this {Event}\n   */\n  composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this['__target'], this.composed);\n    }\n    return /** @type {!Event} */ (this).__composedPath;\n  },\n\n  /**\n   * @this {Event}\n   */\n  get target() {\n    return retarget(\n      this.currentTarget || this['__previousCurrentTarget'],\n      this.composedPath()\n    );\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n  /**\n   * @this {Event}\n   */\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(\n        this.__relatedTarget,\n        true\n      );\n    }\n    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n    return retarget(\n      this.currentTarget || this['__previousCurrentTarget'],\n      /** @type {!Event} */ (this).__relatedTargetComposedPath\n    );\n  },\n  /**\n   * @this {Event}\n   */\n  stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n  /**\n   * @this {Event}\n   */\n  stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  },\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  let klazz = function (type, options) {\n    let event = new Base(type, options);\n    event.__composed = options && Boolean(options['composed']);\n    return event;\n  };\n  // put constructor properties on subclass\n  klazz.__proto__ = Base;\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nlet nonBubblingEventsToRetarget = {\n  'focus': true,\n  'blur': true,\n};\n\n/**\n * Check if the event has been retargeted by comparing original `target`, and calculated `target`\n * @param {Event} event\n * @return {boolean} True if the original target and calculated target are the same\n */\nfunction hasRetargeted(event) {\n  return (\n    event['__target'] !== event.target ||\n    event.__relatedTarget !== event.relatedTarget\n  );\n}\n\n/**\n *\n * @param {Event} event\n * @param {Node} node\n * @param {string} phase\n */\nfunction fireHandlers(event, node, phase) {\n  let hs =\n    node.__handlers &&\n    node.__handlers[event.type] &&\n    node.__handlers[event.type][phase];\n  if (hs) {\n    for (let i = 0, fn; (fn = hs[i]); i++) {\n      if (hasRetargeted(event) && event.target === event.relatedTarget) {\n        return;\n      }\n      fn.call(node, event);\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction shadyDispatchEvent(e) {\n  const path = e.composedPath();\n  const retargetedPath = path.map((node) => retarget(node, path));\n  const bubbles = e.bubbles;\n\n  let currentTarget;\n  // override `currentTarget` to let patched `target` calculate correctly\n  Object.defineProperty(e, 'currentTarget', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      return currentTarget;\n    },\n  });\n\n  let eventPhase = Event.CAPTURING_PHASE;\n  Object.defineProperty(e, 'eventPhase', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      return eventPhase;\n    },\n  });\n\n  for (let i = path.length - 1; i >= 0; i--) {\n    currentTarget = path[i];\n    eventPhase =\n      currentTarget === retargetedPath[i]\n        ? Event.AT_TARGET\n        : Event.CAPTURING_PHASE;\n    // capture phase fires all capture handlers\n    fireHandlers(e, currentTarget, 'capture');\n    if (e.__propagationStopped) {\n      return;\n    }\n  }\n\n  for (let i = 0; i < path.length; i++) {\n    currentTarget = path[i];\n    const atTarget = currentTarget === retargetedPath[i];\n    if (atTarget || bubbles) {\n      eventPhase = atTarget ? Event.AT_TARGET : Event.BUBBLING_PHASE;\n      fireHandlers(e, currentTarget, 'bubble');\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n\n  eventPhase = 0; // `Event.NONE` is not available in IE11.\n  currentTarget = null;\n}\n\nfunction listenerSettingsEqual(\n  savedListener,\n  node,\n  type,\n  capture,\n  once,\n  passive\n) {\n  let {\n    node: savedNode,\n    type: savedType,\n    capture: savedCapture,\n    once: savedOnce,\n    passive: savedPassive,\n  } = savedListener;\n  return (\n    node === savedNode &&\n    type === savedType &&\n    capture === savedCapture &&\n    once === savedOnce &&\n    passive === savedPassive\n  );\n}\n\nexport function findListener(wrappers, node, type, capture, once, passive) {\n  for (let i = 0; i < wrappers.length; i++) {\n    if (\n      listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)\n    ) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run\n * Try/Catch accessing eventWrappers to work around\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074\n */\nfunction getEventWrappers(eventLike) {\n  let wrappers = null;\n  try {\n    wrappers = eventLike[eventWrappersName];\n  } catch (e) {} // eslint-disable-line no-empty\n  return wrappers;\n}\n\nfunction targetNeedsPathCheck(node) {\n  return utils.isShadyRoot(node) || node.localName === 'slot';\n}\n\n/** @this {Node} */\nexport function dispatchEvent(event) {\n  flush();\n  // If the target is disconnected from the real document, it might still be\n  // connected in the user-facing tree. To allow its path to potentially\n  // include both connected and disconnected parts, dispatch it manually.\n  if (\n    !utils.settings.preferPerformance &&\n    this instanceof Node &&\n    !utils.documentContains(document, this)\n  ) {\n    if (!event['__target']) {\n      patchEvent(event, this);\n    }\n    return shadyDispatchEvent(event);\n  } else {\n    return this[utils.NATIVE_PREFIX + 'dispatchEvent'](event);\n  }\n}\n\n/**\n * @this {EventTarget}\n */\nexport function addEventListener(type, fnOrObj, optionsOrCapture) {\n  const {\n    capture,\n    once,\n    passive,\n    shadyTarget,\n    nativeEventOptions,\n  } = parseEventOptions(optionsOrCapture);\n  if (!fnOrObj) {\n    return;\n  }\n\n  const handlerType = typeof fnOrObj;\n\n  // bail if `fnOrObj` is not a function, not an object\n  if (handlerType !== 'function' && handlerType !== 'object') {\n    return;\n  }\n\n  // bail if `fnOrObj` is an object without a `handleEvent` method\n  if (\n    handlerType === 'object' &&\n    (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')\n  ) {\n    return;\n  }\n\n  if (unpatchedEvents[type]) {\n    return this[utils.NATIVE_PREFIX + 'addEventListener'](\n      type,\n      fnOrObj,\n      nativeEventOptions\n    );\n  }\n\n  // hack to let ShadyRoots have event listeners\n  // event listener will be on host, but `currentTarget`\n  // will be set to shadyroot for event listener\n  let target = shadyTarget || this;\n\n  let wrappers = fnOrObj[eventWrappersName];\n  if (wrappers) {\n    // The callback `fn` might be used for multiple nodes/events. Since we generate\n    // a wrapper function, we need to keep track of it when we remove the listener.\n    // It's more efficient to store the node/type/options information as Array in\n    // `fn` itself rather than the node (we assume that the same callback is used\n    // for few nodes at most, whereas a node will likely have many event listeners).\n    // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n    // Stop if the wrapper function has already been created.\n    if (findListener(wrappers, target, type, capture, once, passive) > -1) {\n      return;\n    }\n  } else {\n    fnOrObj[eventWrappersName] = [];\n  }\n\n  /**\n   * @this {HTMLElement}\n   * @param {Event} e\n   */\n  const wrapperFn = function (e) {\n    // Support `once` option.\n    if (once) {\n      this[utils.SHADY_PREFIX + 'removeEventListener'](\n        type,\n        fnOrObj,\n        optionsOrCapture\n      );\n    }\n    if (!e['__target']) {\n      patchEvent(e);\n    }\n    let lastCurrentTargetDesc;\n    let lastEventPhaseDesc;\n    if (target !== this) {\n      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot\n      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(\n        e,\n        'currentTarget'\n      );\n      Object.defineProperty(e, 'currentTarget', {\n        get() {\n          return target;\n        },\n        configurable: true,\n      });\n      lastEventPhaseDesc = Object.getOwnPropertyDescriptor(e, 'eventPhase');\n      Object.defineProperty(e, 'eventPhase', {\n        configurable: true,\n        enumerable: true,\n        get() {\n          // Shady DOM doesn't support dispatching to a shadow root as the\n          // target, so we don't need to handle Event.AT_TARGET.\n          return capture ? Event.CAPTURING_PHASE : Event.BUBBLING_PHASE;\n        },\n      });\n    }\n    e['__previousCurrentTarget'] = e['currentTarget'];\n    // Always check if a shadowRoot or slot is in the current event path.\n    // If it is not, the event was generated on either the host of the shadowRoot\n    // or a children of the host.\n    if (\n      targetNeedsPathCheck(target) &&\n      e.composedPath().indexOf(target) == -1\n    ) {\n      return;\n    }\n    // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n    if (e.composed || e.composedPath().indexOf(target) > -1) {\n      if (hasRetargeted(e) && e.target === e.relatedTarget) {\n        if (e.eventPhase === Event.BUBBLING_PHASE) {\n          e.stopImmediatePropagation();\n        }\n        return;\n      }\n      // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase\n      if (\n        e.eventPhase !== Event.CAPTURING_PHASE &&\n        !e.bubbles &&\n        e.target !== target &&\n        !(target instanceof Window)\n      ) {\n        return;\n      }\n      let ret =\n        handlerType === 'function'\n          ? fnOrObj.call(target, e)\n          : fnOrObj.handleEvent && fnOrObj.handleEvent(e);\n      if (target !== this) {\n        // Replace the original descriptors for `currentTarget` and `eventPhase`.\n        if (lastCurrentTargetDesc) {\n          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);\n          lastCurrentTargetDesc = null;\n        } else {\n          delete e['currentTarget'];\n        }\n        if (lastEventPhaseDesc) {\n          Object.defineProperty(e, 'eventPhase', lastEventPhaseDesc);\n          lastEventPhaseDesc = null;\n        } else {\n          delete e['eventPhase'];\n        }\n      }\n      return ret;\n    }\n  };\n\n  // Store the wrapper information.\n  fnOrObj[eventWrappersName].push({\n    // note: use target here which is either a shadowRoot\n    // (when the host element is proxy'ing the event) or this element\n    node: target,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn,\n  });\n\n  this.__handlers = this.__handlers || {};\n  this.__handlers[type] = this.__handlers[type] || {\n    'capture': [],\n    'bubble': [],\n  };\n  this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\n  if (!nonBubblingEventsToRetarget[type]) {\n    this[utils.NATIVE_PREFIX + 'addEventListener'](\n      type,\n      wrapperFn,\n      nativeEventOptions\n    );\n  }\n}\n\n/**\n * @this {EventTarget}\n */\nexport function removeEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n  const {\n    capture,\n    once,\n    passive,\n    shadyTarget,\n    nativeEventOptions,\n  } = parseEventOptions(optionsOrCapture);\n  if (unpatchedEvents[type]) {\n    return this[utils.NATIVE_PREFIX + 'removeEventListener'](\n      type,\n      fnOrObj,\n      nativeEventOptions\n    );\n  }\n  let target = shadyTarget || this;\n  // Search the wrapped function.\n  let wrapperFn = undefined;\n  let wrappers = getEventWrappers(fnOrObj);\n  if (wrappers) {\n    let idx = findListener(wrappers, target, type, capture, once, passive);\n    if (idx > -1) {\n      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn;\n      // Cleanup.\n      if (!wrappers.length) {\n        fnOrObj[eventWrappersName] = undefined;\n      }\n    }\n  }\n  this[utils.NATIVE_PREFIX + 'removeEventListener'](\n    type,\n    wrapperFn || fnOrObj,\n    nativeEventOptions\n  );\n  if (wrapperFn && this.__handlers && this.__handlers[type]) {\n    const arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n    const idx = arr.indexOf(wrapperFn);\n    if (idx > -1) {\n      arr.splice(idx, 1);\n    }\n  }\n}\n\nfunction activateFocusEventOverrides() {\n  for (let ev in nonBubblingEventsToRetarget) {\n    window[utils.NATIVE_PREFIX + 'addEventListener'](\n      ev,\n      function (e) {\n        if (!e['__target']) {\n          patchEvent(e);\n          shadyDispatchEvent(e);\n        }\n      },\n      true\n    );\n  }\n}\n\nconst EventPatchesDescriptors = utils.getOwnPropertyDescriptors(EventPatches);\n\nconst SHADY_PROTO = '__shady_patchedProto';\nconst SHADY_SOURCE_PROTO = '__shady_sourceProto';\n\nfunction patchEvent(event, target = event.target) {\n  event['__target'] = target;\n  event.__relatedTarget = event.relatedTarget;\n  // attempt to patch prototype (via cache)\n  if (utils.settings.hasDescriptors) {\n    const proto = Object.getPrototypeOf(event);\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto.hasOwnProperty(SHADY_PROTO)) {\n      const patchedProto = Object.create(proto);\n      patchedProto[SHADY_SOURCE_PROTO] = proto;\n      utils.patchProperties(patchedProto, EventPatchesDescriptors);\n      proto[SHADY_PROTO] = patchedProto;\n    }\n    event.__proto__ = proto[SHADY_PROTO];\n    // and fallback to patching instance\n  } else {\n    utils.patchProperties(event, EventPatchesDescriptors);\n  }\n}\n\nlet PatchedEvent = mixinComposedFlag(Event);\nlet PatchedCustomEvent = mixinComposedFlag(CustomEvent);\nlet PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\nexport function patchEvents() {\n  activateFocusEventOverrides();\n  window.Event = PatchedEvent;\n  window.CustomEvent = PatchedCustomEvent;\n  window.MouseEvent = PatchedMouseEvent;\n}\n\nexport function patchClick() {\n  // Fix up `Element.prototype.click()` if `isTrusted` is supported, but `composed` isn't\n  if (\n    !composedGetter &&\n    Object.getOwnPropertyDescriptor(Event.prototype, 'isTrusted')\n  ) {\n    /** @this {Element} */\n    const composedClickFn = function () {\n      const ev = new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n      });\n      this[utils.SHADY_PREFIX + 'dispatchEvent'](ev);\n    };\n    if (Element.prototype.click) {\n      Element.prototype.click = composedClickFn;\n    } else if (HTMLElement.prototype.click) {\n      HTMLElement.prototype.click = composedClickFn;\n    }\n  }\n}\n\nexport const eventPropertyNamesForElement = Object.getOwnPropertyNames(\n  Element.prototype\n).filter((name) => name.substring(0, 2) === 'on');\n\nexport const eventPropertyNamesForHTMLElement = Object.getOwnPropertyNames(\n  HTMLElement.prototype\n).filter((name) => name.substring(0, 2) === 'on');\n\n/**\n * @param {string} property\n * @return {!ObjectPropertyDescriptor<Element>}\n */\nexport const wrappedDescriptorForEventProperty = (property) => {\n  return {\n    /** @this {Element} */\n    set: function (fn) {\n      const shadyData = ensureShadyDataForNode(this);\n      const eventName = property.substring(2);\n      if (!shadyData.__onCallbackListeners) {\n        shadyData.__onCallbackListeners = {};\n      }\n      shadyData.__onCallbackListeners[property] &&\n        this.removeEventListener(\n          eventName,\n          shadyData.__onCallbackListeners[property]\n        );\n      this[utils.SHADY_PREFIX + 'addEventListener'](eventName, fn);\n      shadyData.__onCallbackListeners[property] = fn;\n    },\n    /** @this {Element} */\n    get() {\n      const shadyData = shadyDataForNode(this);\n      return (\n        shadyData &&\n        shadyData.__onCallbackListeners &&\n        shadyData.__onCallbackListeners[property]\n      );\n    },\n    configurable: true,\n  };\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount,\n  };\n}\n\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n\n// Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\nfunction calcEditDistances(\n  current,\n  currentStart,\n  currentEnd,\n  old,\n  oldStart,\n  oldEnd\n) {\n  // \"Deletion\" columns\n  let rowCount = oldEnd - oldStart + 1;\n  let columnCount = currentEnd - currentStart + 1;\n  let distances = new Array(rowCount);\n\n  // \"Addition\" rows. Initialize null column.\n  for (let i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  }\n\n  // Initialize null row\n  for (let j = 0; j < columnCount; j++) {\n    distances[0][j] = j;\n  }\n\n  for (let i = 1; i < rowCount; i++) {\n    for (let j = 1; j < columnCount; j++) {\n      if (equals(current[currentStart + j - 1], old[oldStart + i - 1])) {\n        distances[i][j] = distances[i - 1][j - 1];\n      } else {\n        let north = distances[i - 1][j] + 1;\n        let west = distances[i][j - 1] + 1;\n        distances[i][j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n}\n\n// This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\nfunction spliceOperationsFromEditDistances(distances) {\n  let i = distances.length - 1;\n  let j = distances[0].length - 1;\n  let current = distances[i][j];\n  let edits = [];\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n    let northWest = distances[i - 1][j - 1];\n    let west = distances[i - 1][j];\n    let north = distances[i][j - 1];\n\n    let min;\n    if (west < north) {\n      min = west < northWest ? west : northWest;\n    } else {\n      min = north < northWest ? north : northWest;\n    }\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  let prefixCount = 0;\n  let suffixCount = 0;\n  let splice;\n\n  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) {\n    prefixCount = sharedPrefix(current, old, minLength);\n  }\n\n  if (currentEnd == current.length && oldEnd == old.length) {\n    suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  }\n\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) {\n    return [];\n  }\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart == oldEnd) {\n    return [newSplice(currentStart, [], currentEnd - currentStart)];\n  }\n\n  let ops = spliceOperationsFromEditDistances(\n    calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd)\n  );\n\n  splice = undefined;\n  let splices = [];\n  let index = currentStart;\n  let oldIndex = oldStart;\n  for (let i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n      case EDIT_UPDATE:\n        if (!splice) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n      case EDIT_ADD:\n        if (!splice) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.addedCount++;\n        index++;\n        break;\n      case EDIT_DELETE:\n        if (!splice) {\n          splice = newSplice(index, [], 0);\n        }\n\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (let i = 0; i < searchLength; i++) {\n    if (!equals(current[i], old[i])) {\n      return i;\n    }\n  }\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  let index1 = current.length;\n  let index2 = old.length;\n  let count = 0;\n  while (count < searchLength && equals(current[--index1], old[--index2])) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\nexport function calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\n// prettier-ignore\nimport {addEventListener, removeEventListener, dispatchEvent} from '../patch-events.js';\n\nexport const EventTargetPatches = utils.getOwnPropertyDescriptors({\n  dispatchEvent,\n\n  addEventListener,\n\n  removeEventListener,\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\n\nlet scopingShim = null;\n\nexport function getScopingShim() {\n  if (!scopingShim) {\n    scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];\n  }\n  return scopingShim || null;\n}\n\n/**\n * @param {!Node} node\n * @param {string} attr\n * @param {string} value\n */\nexport function scopeClassAttribute(node, attr, value) {\n  const scopingShim = getScopingShim();\n  if (scopingShim && attr === 'class') {\n    scopingShim['setElementClass'](node, value);\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n */\nexport function addShadyScoping(node, newScopeName) {\n  const scopingShim = getScopingShim();\n  if (!scopingShim) {\n    return;\n  }\n  scopingShim['scopeNode'](node, newScopeName);\n}\n\n/**\n * @param {!Node} node\n * @param {string} currentScopeName\n */\nexport function removeShadyScoping(node, currentScopeName) {\n  const scopingShim = getScopingShim();\n  if (!scopingShim) {\n    return;\n  }\n  scopingShim['unscopeNode'](node, currentScopeName);\n}\n\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @param {string} oldScopeName\n */\nexport function replaceShadyScoping(node, newScopeName, oldScopeName) {\n  const scopingShim = getScopingShim();\n  if (!scopingShim) {\n    return;\n  }\n  if (oldScopeName) {\n    removeShadyScoping(node, oldScopeName);\n  }\n  addShadyScoping(node, newScopeName);\n}\n\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @return {boolean}\n */\nexport function currentScopeIsCorrect(node, newScopeName) {\n  const scopingShim = getScopingShim();\n  if (!scopingShim) {\n    return true;\n  }\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // NOTE: as an optimization, only check that all the top-level children\n    // have the correct scope.\n    let correctScope = true;\n    for (\n      let n = node[utils.SHADY_PREFIX + 'firstChild'];\n      n;\n      n = n[utils.SHADY_PREFIX + 'nextSibling']\n    ) {\n      correctScope = correctScope && currentScopeIsCorrect(n, newScopeName);\n    }\n    return correctScope;\n  }\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n  const currentScope = scopingShim['currentScopeForNode'](node);\n  return currentScope === newScopeName;\n}\n\n/**\n * @param {!Node} node\n * @return {string}\n */\nexport function currentScopeForNode(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n  const scopingShim = getScopingShim();\n  if (!scopingShim) {\n    return '';\n  }\n  return scopingShim['currentScopeForNode'](node);\n}\n\n/**\n * Walk over a node's tree and apply visitorFn to each element node\n *\n * @param {Node} node\n * @param {function(!Node):void} visitorFn\n */\nexport function treeVisitor(node, visitorFn) {\n  if (!node) {\n    return;\n  }\n  // this check is necessary if `node` is a Document Fragment\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    visitorFn(node);\n  }\n  for (\n    let n = node[utils.SHADY_PREFIX + 'firstChild'];\n    n;\n    n = n[utils.SHADY_PREFIX + 'nextSibling']\n  ) {\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      treeVisitor(n, visitorFn);\n    }\n  }\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\n// prettier-ignore\nimport {getScopingShim, removeShadyScoping, replaceShadyScoping, treeVisitor, currentScopeForNode, currentScopeIsCorrect} from '../style-scoping.js';\nimport {shadyDataForNode, ensureShadyDataForNode} from '../shady-data.js';\nimport {recordInsertBefore, recordRemoveChild} from '../link-nodes.js';\nimport {ownerShadyRootForNode} from '../attach-shadow.js';\n\nconst doc = window.document;\n\nconst preferPerformance = utils.settings.preferPerformance;\n\nconst nativeIsConnectedAccessors = /** @type {ObjectPropertyDescriptor} */ (Object.getOwnPropertyDescriptor(\n  Node.prototype,\n  'isConnected'\n));\n\nconst nativeIsConnected =\n  nativeIsConnectedAccessors && nativeIsConnectedAccessors.get;\n\nexport function clearNode(node) {\n  let firstChild;\n  while ((firstChild = node[utils.SHADY_PREFIX + 'firstChild'])) {\n    node[utils.SHADY_PREFIX + 'removeChild'](firstChild);\n  }\n}\n\nfunction removeOwnerShadyRoot(node) {\n  // optimization: only reset the tree if node is actually in a root\n  if (hasCachedOwnerRoot(node)) {\n    for (\n      let n = node[utils.SHADY_PREFIX + 'firstChild'];\n      n;\n      n = n[utils.SHADY_PREFIX + 'nextSibling']\n    ) {\n      removeOwnerShadyRoot(n);\n    }\n  }\n  const nodeData = shadyDataForNode(node);\n  if (nodeData) {\n    nodeData.ownerShadyRoot = undefined;\n  }\n}\n\nfunction hasCachedOwnerRoot(node) {\n  const nodeData = shadyDataForNode(node);\n  return Boolean(nodeData && nodeData.ownerShadyRoot !== undefined);\n}\n\n/**\n * Finds the first flattened node that is composed in the node's parent.\n * If the given node is a slot, then the first flattened node is returned\n * if it exists, otherwise advance to the node's nextSibling.\n * @param {Node} node within which to find first composed node\n * @returns {Node} first composed node\n */\nfunction firstComposedNode(node) {\n  let composed = node;\n  if (node && node.localName === 'slot') {\n    const nodeData = shadyDataForNode(node);\n    const flattened = nodeData && nodeData.flattenedNodes;\n    // Note, if `flattened` is falsey, it means that the containing shadowRoot\n    // has not rendered and therefore the `<slot>` is still in the composed\n    // DOM. If that's the case the `<slot>` is the first composed node.\n    if (flattened) {\n      composed = flattened.length\n        ? flattened[0]\n        : firstComposedNode(node[utils.SHADY_PREFIX + 'nextSibling']);\n    }\n  }\n  return composed;\n}\n\n/**\n * @param {Node} node\n * @param {Node=} addedNode\n * @param {Node=} removedNode\n */\nfunction scheduleObserver(node, addedNode, removedNode) {\n  const nodeData = shadyDataForNode(node);\n  const observer = nodeData && nodeData.observer;\n  if (observer) {\n    if (addedNode) {\n      if (addedNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        for (let i = 0, l = addedNode.childNodes.length; i < l; i++) {\n          observer.addedNodes.push(addedNode.childNodes[i]);\n        }\n      } else {\n        observer.addedNodes.push(addedNode);\n      }\n    }\n    if (removedNode) {\n      observer.removedNodes.push(removedNode);\n    }\n    observer.schedule();\n  }\n}\n\nexport const NodePatches = utils.getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentNode() {\n    const nodeData = shadyDataForNode(this);\n    const l = nodeData && nodeData.parentNode;\n    return l !== undefined ? l : this[utils.NATIVE_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    const nodeData = shadyDataForNode(this);\n    const l = nodeData && nodeData.firstChild;\n    return l !== undefined ? l : this[utils.NATIVE_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    const nodeData = shadyDataForNode(this);\n    const l = nodeData && nodeData.lastChild;\n    return l !== undefined ? l : this[utils.NATIVE_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    const nodeData = shadyDataForNode(this);\n    const l = nodeData && nodeData.nextSibling;\n    return l !== undefined ? l : this[utils.NATIVE_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    const nodeData = shadyDataForNode(this);\n    const l = nodeData && nodeData.previousSibling;\n    return l !== undefined ? l : this[utils.NATIVE_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get childNodes() {\n    let childNodes;\n    if (utils.isTrackingLogicalChildNodes(this)) {\n      const nodeData = shadyDataForNode(this);\n      if (!nodeData.childNodes) {\n        nodeData.childNodes = [];\n        for (\n          let n = this[utils.SHADY_PREFIX + 'firstChild'];\n          n;\n          n = n[utils.SHADY_PREFIX + 'nextSibling']\n        ) {\n          nodeData.childNodes.push(n);\n        }\n      }\n      childNodes = nodeData.childNodes;\n    } else {\n      childNodes = this[utils.NATIVE_PREFIX + 'childNodes'];\n    }\n    childNodes.item = function (index) {\n      return childNodes[index];\n    };\n    return childNodes;\n  },\n\n  /** @this {Node} */\n  get parentElement() {\n    const nodeData = shadyDataForNode(this);\n    let l = nodeData && nodeData.parentNode;\n    if (l && l.nodeType !== Node.ELEMENT_NODE) {\n      l = null;\n    }\n    return l !== undefined ? l : this[utils.NATIVE_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get isConnected() {\n    if (nativeIsConnected && nativeIsConnected.call(this)) {\n      return true;\n    }\n    if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n      return false;\n    }\n    // Fast path for distributed nodes.\n    const ownerDocument = this.ownerDocument;\n    if (ownerDocument === null || utils.documentContains(ownerDocument, this)) {\n      return true;\n    }\n    // Slow path for non-distributed nodes.\n    let node = this;\n    while (node && !(node instanceof Document)) {\n      node =\n        node[utils.SHADY_PREFIX + 'parentNode'] ||\n        (utils.isShadyRoot(node)\n          ? /** @type {ShadowRoot} */ (node).host\n          : undefined);\n    }\n    return !!(node && node instanceof Document);\n  },\n\n  /** @this {Node} */\n  get textContent() {\n    if (utils.isTrackingLogicalChildNodes(this)) {\n      let tc = [];\n      for (\n        let n = this[utils.SHADY_PREFIX + 'firstChild'];\n        n;\n        n = n[utils.SHADY_PREFIX + 'nextSibling']\n      ) {\n        if (n.nodeType !== Node.COMMENT_NODE) {\n          tc.push(n[utils.SHADY_PREFIX + 'textContent']);\n        }\n      }\n      return tc.join('');\n    } else {\n      return this[utils.NATIVE_PREFIX + 'textContent'];\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {string} value\n   */\n  set textContent(value) {\n    if (typeof value === 'undefined' || value === null) {\n      value = '';\n    }\n    switch (this.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        if (\n          !utils.isTrackingLogicalChildNodes(this) &&\n          utils.settings.hasDescriptors\n        ) {\n          // may be removing a nested slot but fast path if we know we are not.\n          const firstChild = this[utils.SHADY_PREFIX + 'firstChild'];\n          if (\n            firstChild != this[utils.SHADY_PREFIX + 'lastChild'] ||\n            (firstChild && firstChild.nodeType != Node.TEXT_NODE)\n          ) {\n            clearNode(this);\n          }\n          this[utils.NATIVE_PREFIX + 'textContent'] = value;\n        } else {\n          clearNode(this);\n          // Document fragments must have no childNodes if setting a blank string\n          if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n            this[utils.SHADY_PREFIX + 'insertBefore'](\n              document.createTextNode(value)\n            );\n          }\n        }\n        break;\n      default:\n        // Note, be wary of patching `nodeValue`.\n        this.nodeValue = value;\n        break;\n    }\n  },\n\n  // Patched `insertBefore`. Note that all mutations that add nodes are routed\n  // here. When a <slot> is added or a node is added to a host with a shadowRoot\n  // with a slot, a standard dom `insert` call is aborted and `_asyncRender`\n  // is called on the relevant shadowRoot. In all other cases, a standard dom\n  // `insert` can be made, but the location and ref_node may need to be changed.\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  insertBefore(node, ref_node) {\n    // optimization: assume native insertBefore is ok if the nodes are not in the document.\n    if (this.ownerDocument !== doc && node.ownerDocument !== doc) {\n      this[utils.NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      return node;\n    }\n    if (node === this) {\n      throw Error(\n        `Failed to execute 'appendChild' on 'Node': The new child element contains the parent.`\n      );\n    }\n    if (ref_node) {\n      const refData = shadyDataForNode(ref_node);\n      const p = refData && refData.parentNode;\n      if (\n        (p !== undefined && p !== this) ||\n        (p === undefined &&\n          ref_node[utils.NATIVE_PREFIX + 'parentNode'] !== this)\n      ) {\n        throw Error(\n          `Failed to execute 'insertBefore' on 'Node': The node ` +\n            `before which the new node is to be inserted is not a child of this node.`\n        );\n      }\n    }\n    if (ref_node === node) {\n      return node;\n    }\n    scheduleObserver(this, node);\n    /** @type {!Array<!HTMLSlotElement>} */\n    const slotsAdded = [];\n    const ownerRoot = ownerShadyRootForNode(this);\n    /** @type {string} */\n    const newScopeName = ownerRoot\n      ? ownerRoot.host.localName\n      : currentScopeForNode(this);\n    /** @type {string} */\n    let oldScopeName;\n    // remove from existing location\n    const parentNode = node[utils.SHADY_PREFIX + 'parentNode'];\n    if (parentNode) {\n      oldScopeName = currentScopeForNode(node);\n      const skipUnscoping =\n        // Don't remove scoping if we're inserting into another shadowRoot;\n        // this would be unnecessary since it will be re-scoped below\n        Boolean(ownerRoot) ||\n        // Don't remove scoping if we're being moved between non-shadowRoot\n        // locations (the likely case is when moving pre-scoped nodes in a template)\n        !ownerShadyRootForNode(node) ||\n        // Under preferPerformance, don't remove scoping when moving back into\n        // a document fragment that was previously scoped; the assumption is\n        // that the user should only move correctly-scoped DOM back into it\n        (preferPerformance && this['__noInsertionPoint'] !== undefined);\n      parentNode[utils.SHADY_PREFIX + 'removeChild'](node, skipUnscoping);\n    }\n    // add to new parent\n    let allowNativeInsert = true;\n    const needsScoping =\n      (!preferPerformance ||\n        // Under preferPerformance, only re-scope if we're not coming from a\n        // pre-scoped doc fragment or back into a pre-scoped doc fragment\n        (node['__noInsertionPoint'] === undefined &&\n          this['__noInsertionPoint'] === undefined)) &&\n      !currentScopeIsCorrect(node, newScopeName);\n    const needsSlotFinding =\n      ownerRoot &&\n      !node['__noInsertionPoint'] &&\n      (!preferPerformance || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n    if (needsSlotFinding || needsScoping) {\n      // NOTE: avoid node.removeChild as this *can* trigger another patched\n      // method (e.g. custom elements) and we want only the shady method to run.\n      // The following table describes what style scoping actions should happen as a result of this insertion.\n      // document -> shadowRoot: replace\n      // shadowRoot -> shadowRoot: replace\n      // shadowRoot -> shadowRoot of same type: do nothing\n      // shadowRoot -> document: allow unscoping\n      // document -> document: do nothing\n      // The \"same type of shadowRoot\" and \"document to document cases rely on `currentScopeIsCorrect` returning true\n      if (needsScoping) {\n        // in a document or disconnected tree, replace scoping if necessary\n        oldScopeName = oldScopeName || currentScopeForNode(node);\n      }\n      treeVisitor(node, (node) => {\n        if (needsSlotFinding && node.localName === 'slot') {\n          slotsAdded.push(/** @type {!HTMLSlotElement} */ (node));\n        }\n        if (needsScoping) {\n          replaceShadyScoping(node, newScopeName, oldScopeName);\n        }\n      });\n    }\n    // if a slot is added, must render containing root.\n    if (slotsAdded.length) {\n      ownerRoot._addSlots(slotsAdded);\n      ownerRoot._asyncRender();\n    }\n    if (utils.isTrackingLogicalChildNodes(this)) {\n      recordInsertBefore(node, this, ref_node);\n      const parentData = shadyDataForNode(this);\n      // if the node being inserted into has a shadowRoot, do not perform\n      // a native insertion\n      if (parentData.root) {\n        allowNativeInsert = false;\n        // when inserting into a host with a shadowRoot with slot, use\n        // `shadowRoot._asyncRender()` via `attach-shadow` module\n        // when inserting into a host with shadowRoot with NO slot, do nothing\n        // as the node should not be added to composed DOM anywhere.\n        if (utils.hasShadowRootWithSlot(this)) {\n          parentData.root._asyncRender();\n        }\n      }\n      // when inserting into a slot inside a shadowRoot, render the\n      // containing shadowRoot to update fallback content.\n      else if (ownerRoot && this.localName === 'slot') {\n        allowNativeInsert = false;\n        ownerRoot._asyncRender();\n      }\n    }\n    if (allowNativeInsert) {\n      // if adding to a shadyRoot, add to host instead\n      let container = utils.isShadyRoot(this)\n        ? /** @type {ShadowRoot} */ (this).host\n        : this;\n      // if ref_node, get the ref_node that's actually in composed dom.\n      if (ref_node) {\n        ref_node = firstComposedNode(ref_node);\n        container[utils.NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      } else {\n        container[utils.NATIVE_PREFIX + 'appendChild'](node);\n      }\n    }\n    // Since ownerDocument is not patched, it can be incorrect after this call\n    // if the node is physically appended via distribution. This can result\n    // in the custom elements polyfill not upgrading the node if it's in an inert doc.\n    // We correct this by calling `adoptNode`.\n    else if (node.ownerDocument !== this.ownerDocument) {\n      this.ownerDocument.adoptNode(node);\n    }\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   */\n  appendChild(node) {\n    // if this is a shadowRoot and the shadowRoot is passed as `node`\n    // then an optimized append has already been performed, so do nothing.\n    if (!(this == node && utils.isShadyRoot(node))) {\n      return this[utils.SHADY_PREFIX + 'insertBefore'](node);\n    }\n  },\n\n  /**\n   * Patched `removeChild`. Note that all dom \"removals\" are routed here.\n   * Removes the given `node` from the element's `children`.\n   * This method also performs dom composition.\n   * @this {Node}\n   * @param {Node} node\n   * @param {boolean=} skipUnscoping\n   */\n  removeChild(node, skipUnscoping = false) {\n    if (this.ownerDocument !== doc) {\n      return this[utils.NATIVE_PREFIX + 'removeChild'](node);\n    }\n    if (node[utils.SHADY_PREFIX + 'parentNode'] !== this) {\n      throw Error(\n        'The node to be removed is not a child of this node: ' + node\n      );\n    }\n    scheduleObserver(this, null, node);\n    let preventNativeRemove;\n    let ownerRoot = ownerShadyRootForNode(node);\n    const removingInsertionPoint =\n      ownerRoot && ownerRoot._removeContainedSlots(node);\n    const parentData = shadyDataForNode(this);\n    if (utils.isTrackingLogicalChildNodes(this)) {\n      recordRemoveChild(node, this);\n      if (utils.hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n        preventNativeRemove = true;\n      }\n    }\n    // unscope a node leaving a ShadowRoot if ShadyCSS is present, and this node\n    // is not going to be rescoped in `insertBefore`\n    if (\n      getScopingShim() &&\n      !skipUnscoping &&\n      ownerRoot &&\n      node.nodeType !== Node.TEXT_NODE\n    ) {\n      const oldScopeName = currentScopeForNode(node);\n      treeVisitor(node, (node) => {\n        removeShadyScoping(node, oldScopeName);\n      });\n    }\n    removeOwnerShadyRoot(node);\n    // if removing slot, must render containing root\n    if (ownerRoot) {\n      let changeSlotContent = this.localName === 'slot';\n      if (changeSlotContent) {\n        preventNativeRemove = true;\n      }\n      if (removingInsertionPoint || changeSlotContent) {\n        ownerRoot._asyncRender();\n      }\n    }\n    if (!preventNativeRemove) {\n      // if removing from a shadyRoot, remove from host instead\n      let container = utils.isShadyRoot(this)\n        ? /** @type {ShadowRoot} */ (this).host\n        : this;\n      // not guaranteed to physically be in container; e.g.\n      // (1) if parent has a shadyRoot, element may or may not at distributed\n      // location (could be undistributed)\n      // (2) if parent is a slot, element may not ben in composed dom\n      if (\n        !(parentData.root || node.localName === 'slot') ||\n        container === node[utils.NATIVE_PREFIX + 'parentNode']\n      ) {\n        container[utils.NATIVE_PREFIX + 'removeChild'](node);\n      }\n    }\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  replaceChild(node, ref_node) {\n    this[utils.SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    this[utils.SHADY_PREFIX + 'removeChild'](ref_node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {boolean=} deep\n   */\n  cloneNode(deep) {\n    if (this.localName == 'template') {\n      return this[utils.NATIVE_PREFIX + 'cloneNode'](deep);\n    } else {\n      const n = this[utils.NATIVE_PREFIX + 'cloneNode'](false);\n      // Attribute nodes historically had childNodes, but they have later\n      // been removed from the spec.\n      // Make sure we do not do a deep clone on them for old browsers (IE11)\n      if (deep && n.nodeType !== Node.ATTRIBUTE_NODE) {\n        for (\n          let c = this[utils.SHADY_PREFIX + 'firstChild'], nc;\n          c;\n          c = c[utils.SHADY_PREFIX + 'nextSibling']\n        ) {\n          nc = c[utils.SHADY_PREFIX + 'cloneNode'](true);\n          n[utils.SHADY_PREFIX + 'appendChild'](nc);\n        }\n      }\n      return n;\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {Object=} options\n   */\n  // TODO(sorvell): implement `options` e.g. `{ composed: boolean }`\n  getRootNode(options) {\n    if (!this || !this.nodeType) {\n      return;\n    }\n    const nodeData = ensureShadyDataForNode(this);\n    let root = nodeData.ownerShadyRoot;\n    if (root === undefined) {\n      if (utils.isShadyRoot(this)) {\n        root = this;\n        nodeData.ownerShadyRoot = root;\n      } else {\n        let parent = this[utils.SHADY_PREFIX + 'parentNode'];\n        root = parent\n          ? parent[utils.SHADY_PREFIX + 'getRootNode'](options)\n          : this;\n        // memo-ize result for performance but only memo-ize\n        // result if node is in the document. This avoids a problem where a root\n        // can be cached while an element is inside a fragment.\n        // If this happens and we cache the result, the value can become stale\n        // because for perf we avoid processing the subtree of added fragments.\n        if (document.documentElement[utils.NATIVE_PREFIX + 'contains'](this)) {\n          nodeData.ownerShadyRoot = root;\n        }\n      }\n    }\n    return root;\n  },\n\n  /** @this {Node} */\n  contains(node) {\n    return utils.contains(this, node);\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport {calculateSplices} from './array-splice.js';\nimport * as utils from './utils.js';\nimport {enqueue} from './flush.js';\nimport {ensureShadyDataForNode, shadyDataForNode} from './shady-data.js';\nimport {recordChildNodes} from './link-nodes.js';\nimport {patchShadyRoot} from './patch-shadyRoot.js';\n\n// Do not export this object. It must be passed as the first argument to the\n// ShadyRoot constructor in `attachShadow` to prevent the constructor from\n// throwing. This prevents the user from being able to manually construct a\n// ShadyRoot (i.e. `new ShadowRoot()`).\nconst ShadyRootConstructionToken = {};\n\nconst CATCHALL_NAME = '__catchall';\n\nconst MODE_CLOSED = 'closed';\n\nlet isRendering =\n  utils.settings['deferConnectionCallbacks'] &&\n  document.readyState === 'loading';\nlet rootRendered;\n\nfunction ancestorList(node) {\n  let ancestors = [];\n  do {\n    ancestors.unshift(node);\n  } while ((node = node[utils.SHADY_PREFIX + 'parentNode']));\n  return ancestors;\n}\n\n/**\n * @extends {ShadowRoot}\n */\nclass ShadyRoot {\n  constructor(token, host, options) {\n    if (token !== ShadyRootConstructionToken) {\n      throw new TypeError('Illegal constructor');\n    }\n    /** @type {boolean} */\n    this._renderPending;\n    /** @type {boolean} */\n    this._hasRendered;\n    /** @type {?Array<HTMLSlotElement>} */\n    this._slotList = null;\n    /** @type {?Object<string, Array<HTMLSlotElement>>} */\n    this._slotMap;\n    /** @type {?Array<HTMLSlotElement>} */\n    this._pendingSlots;\n    this._init(host, options);\n  }\n\n  _init(host, options) {\n    // root <=> host\n    this.host = host;\n    /** @type {!string|undefined} */\n    this.mode = options && options.mode;\n    recordChildNodes(this.host);\n    const hostData = ensureShadyDataForNode(this.host);\n    /** @type {!ShadyRoot} */\n    hostData.root = this;\n    hostData.publicRoot = this.mode !== MODE_CLOSED ? this : null;\n    // setup root\n    const rootData = ensureShadyDataForNode(this);\n    rootData.firstChild = rootData.lastChild = rootData.parentNode = rootData.nextSibling = rootData.previousSibling = null;\n    // NOTE: optimization flag, only require an asynchronous render\n    // to record parsed children if flag is not set.\n    if (utils.settings['preferPerformance']) {\n      let n;\n      while ((n = this.host[utils.NATIVE_PREFIX + 'firstChild'])) {\n        this.host[utils.NATIVE_PREFIX + 'removeChild'](n);\n      }\n    } else {\n      this._asyncRender();\n    }\n  }\n\n  _asyncRender() {\n    if (!this._renderPending) {\n      this._renderPending = true;\n      enqueue(() => this._render());\n    }\n  }\n\n  // returns the oldest renderPending ancestor root.\n  _getPendingDistributionRoot() {\n    let renderRoot;\n    let root = this;\n    while (root) {\n      if (root._renderPending) {\n        renderRoot = root;\n      }\n      root = root._getDistributionParent();\n    }\n    return renderRoot;\n  }\n\n  // Returns the shadyRoot `this.host` if `this.host`\n  // has children that require distribution.\n  _getDistributionParent() {\n    let root = this.host[utils.SHADY_PREFIX + 'getRootNode']();\n    if (!utils.isShadyRoot(root)) {\n      return;\n    }\n    const nodeData = shadyDataForNode(this.host);\n    if (nodeData && nodeData.__childSlotCount > 0) {\n      return root;\n    }\n  }\n\n  // Renders the top most render pending shadowRoot in the distribution tree.\n  // This is safe because when a distribution parent renders, all children render.\n  _render() {\n    // If this root is not pending, it needs no rendering work. Any pending\n    // parent that needs to render wll cause this root to render.\n    const root = this._renderPending && this._getPendingDistributionRoot();\n    if (root) {\n      root._renderSelf();\n    }\n  }\n\n  _flushInitial() {\n    if (!this._hasRendered && this._renderPending) {\n      this._render();\n    }\n  }\n\n  /** @override */\n  _renderSelf() {\n    // track rendering state.\n    const wasRendering = isRendering;\n    isRendering = true;\n    this._renderPending = false;\n    if (this._slotList) {\n      this._distribute();\n      this._compose();\n    }\n    // NOTE: optimization flag, only process parsed children\n    // if optimization flag is not set.\n    // on initial render remove any undistributed children.\n    if (!utils.settings['preferPerformance'] && !this._hasRendered) {\n      for (\n        let n = this.host[utils.SHADY_PREFIX + 'firstChild'];\n        n;\n        n = n[utils.SHADY_PREFIX + 'nextSibling']\n      ) {\n        const data = shadyDataForNode(n);\n        if (\n          n[utils.NATIVE_PREFIX + 'parentNode'] === this.host &&\n          (n.localName === 'slot' || !data.assignedSlot)\n        ) {\n          this.host[utils.NATIVE_PREFIX + 'removeChild'](n);\n        }\n      }\n    }\n    this._hasRendered = true;\n    isRendering = wasRendering;\n    if (rootRendered) {\n      rootRendered();\n    }\n  }\n\n  _distribute() {\n    this._validateSlots();\n    // capture # of previously assigned nodes to help determine if dirty.\n    for (let i = 0, slot; i < this._slotList.length; i++) {\n      slot = this._slotList[i];\n      this._clearSlotAssignedNodes(slot);\n    }\n    // distribute host children.\n    for (\n      let n = this.host[utils.SHADY_PREFIX + 'firstChild'];\n      n;\n      n = n[utils.SHADY_PREFIX + 'nextSibling']\n    ) {\n      this._distributeNodeToSlot(n);\n    }\n    // fallback content, slotchange, and dirty roots\n    for (let i = 0; i < this._slotList.length; i++) {\n      const slot = this._slotList[i];\n      const slotData = shadyDataForNode(slot);\n      // distribute fallback content\n      if (!slotData.assignedNodes.length) {\n        for (\n          let n = slot[utils.SHADY_PREFIX + 'firstChild'];\n          n;\n          n = n[utils.SHADY_PREFIX + 'nextSibling']\n        ) {\n          this._distributeNodeToSlot(n, slot);\n        }\n      }\n      const slotParentData = shadyDataForNode(\n        slot[utils.SHADY_PREFIX + 'parentNode']\n      );\n      const slotParentRoot = slotParentData && slotParentData.root;\n      if (\n        slotParentRoot &&\n        (slotParentRoot._hasInsertionPoint() || slotParentRoot._renderPending)\n      ) {\n        slotParentRoot._renderSelf();\n      }\n      this._addAssignedToFlattenedNodes(\n        slotData.flattenedNodes,\n        slotData.assignedNodes\n      );\n      let prevAssignedNodes = slotData._previouslyAssignedNodes;\n      if (prevAssignedNodes) {\n        for (let i = 0; i < prevAssignedNodes.length; i++) {\n          shadyDataForNode(prevAssignedNodes[i])._prevAssignedSlot = null;\n        }\n        slotData._previouslyAssignedNodes = null;\n        // dirty if previously less assigned nodes than previously assigned.\n        if (prevAssignedNodes.length > slotData.assignedNodes.length) {\n          slotData.dirty = true;\n        }\n      }\n      /* Note: A slot is marked dirty whenever a node is newly assigned to it\n      or a node is assigned to a different slot (done in `_distributeNodeToSlot`)\n      or if the number of nodes assigned to the slot has decreased (done above);\n      */\n      if (slotData.dirty) {\n        slotData.dirty = false;\n        this._fireSlotChange(slot);\n      }\n    }\n  }\n\n  /**\n   * Distributes given `node` to the appropriate slot based on its `slot`\n   * attribute. If `forcedSlot` is given, then the node is distributed to the\n   * `forcedSlot`.\n   * Note: slot to which the node is assigned will be marked dirty for firing\n   * `slotchange`.\n   * @param {Node} node\n   * @param {Node=} forcedSlot\n   *\n   */\n  _distributeNodeToSlot(node, forcedSlot) {\n    const nodeData = ensureShadyDataForNode(node);\n    let oldSlot = nodeData._prevAssignedSlot;\n    nodeData._prevAssignedSlot = null;\n    let slot = forcedSlot;\n    if (!slot) {\n      let name = node[utils.SHADY_PREFIX + 'slot'] || CATCHALL_NAME;\n      const list = this._slotMap[name];\n      slot = list && list[0];\n    }\n    if (slot) {\n      const slotData = ensureShadyDataForNode(slot);\n      slotData.assignedNodes.push(node);\n      nodeData.assignedSlot = slot;\n    } else {\n      nodeData.assignedSlot = undefined;\n    }\n    if (oldSlot !== nodeData.assignedSlot) {\n      if (nodeData.assignedSlot) {\n        ensureShadyDataForNode(nodeData.assignedSlot).dirty = true;\n      }\n    }\n  }\n\n  /**\n   * Clears the assignedNodes tracking data for a given `slot`. Note, the current\n   * assigned node data is tracked (via _previouslyAssignedNodes and\n   * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out\n   *  of date at this time because the assigned nodes may have already been\n   * distributed to another root. This is ok since this data is only used to\n   * track changes.\n   * @param {HTMLSlotElement} slot\n   */\n  _clearSlotAssignedNodes(slot) {\n    const slotData = shadyDataForNode(slot);\n    let n$ = slotData.assignedNodes;\n    slotData.assignedNodes = [];\n    slotData.flattenedNodes = [];\n    slotData._previouslyAssignedNodes = n$;\n    if (n$) {\n      for (let i = 0; i < n$.length; i++) {\n        let n = shadyDataForNode(n$[i]);\n        n._prevAssignedSlot = n.assignedSlot;\n        // only clear if it was previously set to this slot;\n        // this helps ensure that if the node has otherwise been distributed\n        // ignore it.\n        if (n.assignedSlot === slot) {\n          n.assignedSlot = null;\n        }\n      }\n    }\n  }\n\n  _addAssignedToFlattenedNodes(flattened, assigned) {\n    for (let i = 0, n; i < assigned.length && (n = assigned[i]); i++) {\n      if (n.localName == 'slot') {\n        const nestedAssigned = shadyDataForNode(n).assignedNodes;\n        if (nestedAssigned && nestedAssigned.length) {\n          this._addAssignedToFlattenedNodes(flattened, nestedAssigned);\n        }\n      } else {\n        flattened.push(assigned[i]);\n      }\n    }\n  }\n\n  _fireSlotChange(slot) {\n    // NOTE: cannot bubble correctly here so not setting bubbles: true\n    // Safari tech preview does not bubble but chrome does\n    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n    slot[utils.NATIVE_PREFIX + 'dispatchEvent'](new Event('slotchange'));\n    const slotData = shadyDataForNode(slot);\n    if (slotData.assignedSlot) {\n      this._fireSlotChange(slotData.assignedSlot);\n    }\n  }\n\n  // Reify dom such that it is at its correct rendering position\n  // based on logical distribution.\n  // NOTE: here we only compose parents of <slot> elements and not the\n  // shadowRoot into the host. The latter is performend via a fast path\n  // in the `logical-mutation`.insertBefore.\n  _compose() {\n    const slots = this._slotList;\n    let composeList = [];\n    for (let i = 0; i < slots.length; i++) {\n      const parent = slots[i][utils.SHADY_PREFIX + 'parentNode'];\n      /* compose node only if:\n        (1) parent does not have a shadowRoot since shadowRoot has already\n        composed into the host\n        (2) we're not already composing it\n        [consider (n^2) but rare better than Set]\n      */\n      const parentData = shadyDataForNode(parent);\n      if (!(parentData && parentData.root) && composeList.indexOf(parent) < 0) {\n        composeList.push(parent);\n      }\n    }\n    for (let i = 0; i < composeList.length; i++) {\n      const node = composeList[i];\n      const targetNode = node === this ? this.host : node;\n      this._updateChildNodes(targetNode, this._composeNode(node));\n    }\n  }\n\n  // Returns the list of nodes which should be rendered inside `node`.\n  _composeNode(node) {\n    let children = [];\n    for (\n      let n = node[utils.SHADY_PREFIX + 'firstChild'];\n      n;\n      n = n[utils.SHADY_PREFIX + 'nextSibling']\n    ) {\n      // Note: if we see a slot here, the nodes are guaranteed to need to be\n      // composed here. This is because if there is redistribution, it has\n      // already been handled by this point.\n      if (this._isInsertionPoint(n)) {\n        let flattenedNodes = shadyDataForNode(n).flattenedNodes;\n        for (let j = 0; j < flattenedNodes.length; j++) {\n          let distributedNode = flattenedNodes[j];\n          children.push(distributedNode);\n        }\n      } else {\n        children.push(n);\n      }\n    }\n    return children;\n  }\n\n  _isInsertionPoint(node) {\n    return node.localName == 'slot';\n  }\n\n  // Ensures that the rendered node list inside `container` is `children`.\n  _updateChildNodes(container, children) {\n    let composed = utils.nativeChildNodesArray(container);\n    let splices = calculateSplices(children, composed);\n    // process removals\n    for (let i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\n      for (let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n        // check if the node is still where we expect it is before trying\n        // to remove it; this can happen if we move a node and\n        // then schedule its previous host for distribution resulting in\n        // the node being removed here.\n        if (n[utils.NATIVE_PREFIX + 'parentNode'] === container) {\n          container[utils.NATIVE_PREFIX + 'removeChild'](n);\n        }\n        // TODO(sorvell): avoid the need for splicing here.\n        composed.splice(s.index + d, 1);\n      }\n      d -= s.addedCount;\n    }\n    // process adds\n    for (let i = 0, s, next; i < splices.length && (s = splices[i]); i++) {\n      // eslint-disable-line no-redeclare\n      next = composed[s.index];\n      for (let j = s.index, n; j < s.index + s.addedCount; j++) {\n        n = children[j];\n        container[utils.NATIVE_PREFIX + 'insertBefore'](n, next);\n        composed.splice(j, 0, n);\n      }\n    }\n  }\n\n  _ensureSlotData() {\n    this._pendingSlots = this._pendingSlots || [];\n    this._slotList = this._slotList || [];\n    this._slotMap = this._slotMap || {};\n  }\n\n  _addSlots(slots) {\n    this._ensureSlotData();\n    this._pendingSlots.push(...slots);\n  }\n\n  _validateSlots() {\n    if (this._pendingSlots && this._pendingSlots.length) {\n      this._mapSlots(this._pendingSlots);\n      this._pendingSlots = [];\n    }\n  }\n\n  /**\n   * Adds the given slots. Slots are maintained in an dom-ordered list.\n   * In addition a map of name to slot is updated.\n   */\n  _mapSlots(slots) {\n    let slotNamesToSort;\n    for (let i = 0; i < slots.length; i++) {\n      const slot = slots[i];\n      // ensure insertionPoints's and their parents have logical dom info.\n      // save logical tree info\n      // a. for shadyRoot\n      // b. for insertion points (fallback)\n      // c. for parents of insertion points\n      recordChildNodes(slot);\n      const slotParent = slot[utils.SHADY_PREFIX + 'parentNode'];\n      recordChildNodes(slotParent);\n      const slotParentData = shadyDataForNode(slotParent);\n      slotParentData.__childSlotCount =\n        (slotParentData.__childSlotCount || 0) + 1;\n      let name = this._nameForSlot(slot);\n      if (this._slotMap[name]) {\n        slotNamesToSort = slotNamesToSort || {};\n        slotNamesToSort[name] = true;\n        this._slotMap[name].push(slot);\n      } else {\n        this._slotMap[name] = [slot];\n      }\n      this._slotList.push(slot);\n    }\n    if (slotNamesToSort) {\n      for (let n in slotNamesToSort) {\n        this._slotMap[n] = this._sortSlots(this._slotMap[n]);\n      }\n    }\n  }\n\n  _nameForSlot(slot) {\n    const name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;\n    slot.__slotName = name;\n    return name;\n  }\n\n  /**\n   * Slots are kept in an ordered list. Slots with the same name\n   * are sorted here by tree order.\n   */\n  _sortSlots(slots) {\n    // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,\n    // but the code here could be used to polyfill the preceeding/following info\n    // in `compareDocumentPosition`.\n    return slots.sort((a, b) => {\n      let listA = ancestorList(a);\n      let listB = ancestorList(b);\n      for (var i = 0; i < listA.length; i++) {\n        let nA = listA[i];\n        let nB = listB[i];\n        if (nA !== nB) {\n          let c$ = utils.childNodesArray(nA[utils.SHADY_PREFIX + 'parentNode']);\n          return c$.indexOf(nA) - c$.indexOf(nB);\n        }\n      }\n    });\n  }\n\n  /**\n   * Removes from tracked slot data any slots contained within `container` and\n   * then updates the tracked data (_slotList and _slotMap).\n   * Any removed slots also have their `assignedNodes` removed from comopsed dom.\n   */\n  _removeContainedSlots(container) {\n    if (!this._slotList) {\n      return;\n    }\n    this._validateSlots();\n    let didRemove;\n    const map = this._slotMap;\n    for (let n in map) {\n      const slots = map[n];\n      for (let i = 0; i < slots.length; i++) {\n        const slot = slots[i];\n        if (utils.contains(container, slot)) {\n          slots.splice(i, 1);\n          const x = this._slotList.indexOf(slot);\n          if (x >= 0) {\n            this._slotList.splice(x, 1);\n            const slotParentData = shadyDataForNode(\n              slot[utils.SHADY_PREFIX + 'parentNode']\n            );\n            if (slotParentData && slotParentData.__childSlotCount) {\n              slotParentData.__childSlotCount--;\n            }\n          }\n          i--;\n          this._removeFlattenedNodes(slot);\n          didRemove = true;\n        }\n      }\n    }\n    return didRemove;\n  }\n\n  _updateSlotName(slot) {\n    if (!this._slotList) {\n      return;\n    }\n    // make sure slotMap is initialized with this slot\n    this._validateSlots();\n    const oldName = slot.__slotName;\n    const name = this._nameForSlot(slot);\n    if (name === oldName) {\n      return;\n    }\n    // remove from existing tracking\n    let slots = this._slotMap[oldName];\n    const i = slots.indexOf(slot);\n    if (i >= 0) {\n      slots.splice(i, 1);\n    }\n    // add to new location and sort if nedessary\n    let list = this._slotMap[name] || (this._slotMap[name] = []);\n    list.push(slot);\n    if (list.length > 1) {\n      this._slotMap[name] = this._sortSlots(list);\n    }\n  }\n\n  _removeFlattenedNodes(slot) {\n    const data = shadyDataForNode(slot);\n    let n$ = data.flattenedNodes;\n    if (n$) {\n      for (let i = 0; i < n$.length; i++) {\n        let node = n$[i];\n        let parent = node[utils.NATIVE_PREFIX + 'parentNode'];\n        if (parent) {\n          parent[utils.NATIVE_PREFIX + 'removeChild'](node);\n        }\n      }\n    }\n    data.flattenedNodes = [];\n    data.assignedNodes = [];\n  }\n\n  _hasInsertionPoint() {\n    this._validateSlots();\n    return Boolean(this._slotList && this._slotList.length);\n  }\n}\n\npatchShadyRoot(ShadyRoot.prototype);\nexport {ShadyRoot};\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\nexport const attachShadow = (host, options) => {\n  if (!host) {\n    throw new Error('Must provide a host.');\n  }\n  if (!options) {\n    throw new Error('Not enough arguments.');\n  }\n  let root;\n  // Optimization for booting up a shadowRoot from a fragment rather than\n  // creating one.\n  if (options['shadyUpgradeFragment'] && utils.canUpgrade()) {\n    root = options['shadyUpgradeFragment'];\n    root.__proto__ = ShadowRoot.prototype;\n    root._init(host, options);\n    recordChildNodes(root, root);\n    // Note: qsa is native when used with noPatch.\n    /** @type {?NodeList<Element>} */\n    const slotsAdded = root['__noInsertionPoint']\n      ? null\n      : root.querySelectorAll('slot');\n    // Reset scoping information so normal scoing rules apply after this.\n    root['__noInsertionPoint'] = undefined;\n    // if a slot is added, must render containing root.\n    if (slotsAdded && slotsAdded.length) {\n      root._addSlots(slotsAdded);\n      root._asyncRender();\n    }\n    /** @type {ShadowRoot} */ (root).host[utils.NATIVE_PREFIX + 'appendChild'](\n      root\n    );\n  } else {\n    root = new ShadyRoot(ShadyRootConstructionToken, host, options);\n  }\n  return root;\n};\n\n// Mitigate connect/disconnect spam by wrapping custom element classes. This\n// should happen if custom elements are available in any capacity, polyfilled or\n// not.\nif (\n  utils.hasCustomElements() &&\n  utils.settings.inUse &&\n  !utils.settings['preferPerformance']\n) {\n  // process connect/disconnect after roots have rendered to avoid\n  // issues with reaction stack.\n  let connectMap = new Map();\n  rootRendered = function () {\n    // allow elements to connect\n    // save map state (without needing polyfills on IE11)\n    const r = [];\n    connectMap.forEach((v, k) => {\n      r.push([k, v]);\n    });\n    connectMap.clear();\n    for (let i = 0; i < r.length; i++) {\n      const e = r[i][0],\n        value = r[i][1];\n      if (value) {\n        e['__shadydom_connectedCallback']();\n      } else {\n        e['__shadydom_disconnectedCallback']();\n      }\n    }\n  };\n\n  // Document is in loading state and flag is set (deferConnectionCallbacks)\n  // so process connection stack when `readystatechange` fires.\n  if (isRendering) {\n    document.addEventListener(\n      'readystatechange',\n      () => {\n        isRendering = false;\n        rootRendered();\n      },\n      {once: true}\n    );\n  }\n\n  /*\n   * (1) elements can only be connected/disconnected if they are in the expected\n   * state.\n   * (2) never run connect/disconnect during rendering to avoid reaction stack issues.\n   */\n  const ManageConnect = (base, connected, disconnected) => {\n    let counter = 0;\n    const connectFlag = `__isConnected${counter++}`;\n    if (connected || disconnected) {\n      /** @this {!HTMLElement} */\n      base.prototype.connectedCallback = base.prototype[\n        '__shadydom_connectedCallback'\n      ] = function () {\n        // if rendering defer connected\n        // otherwise connect only if we haven't already\n        if (isRendering) {\n          connectMap.set(this, true);\n        } else if (!this[connectFlag]) {\n          this[connectFlag] = true;\n          if (connected) {\n            connected.call(this);\n          }\n        }\n      };\n\n      /** @this {!HTMLElement} */\n      base.prototype.disconnectedCallback = base.prototype[\n        '__shadydom_disconnectedCallback'\n      ] = function () {\n        // if rendering, cancel a pending connection and queue disconnect,\n        // otherwise disconnect only if a connection has been allowed\n        if (isRendering) {\n          // This is necessary only because calling removeChild\n          // on a node that requires distribution leaves it in the DOM tree\n          // until distribution.\n          // NOTE: remember this is checking the patched isConnected to determine\n          // if the node is in the logical tree.\n          if (!this.isConnected) {\n            connectMap.set(this, false);\n          }\n        } else if (this[connectFlag]) {\n          this[connectFlag] = false;\n          if (disconnected) {\n            disconnected.call(this);\n          }\n        }\n      };\n    }\n\n    return base;\n  };\n\n  const originalDefine = window['customElements']['define'];\n  const define = function (name, constructor) {\n    const connected = constructor.prototype.connectedCallback;\n    const disconnected = constructor.prototype.disconnectedCallback;\n    originalDefine.call(\n      window['customElements'],\n      name,\n      ManageConnect(constructor, connected, disconnected)\n    );\n    // unpatch connected/disconnected on class; custom elements tears this off\n    // so the patch is maintained, but if the user calls these methods for\n    // e.g. testing, they will be as expected.\n    constructor.prototype.connectedCallback = connected;\n    constructor.prototype.disconnectedCallback = disconnected;\n  };\n  // Note, it would be better to only patch the CustomElementRegistry.prototype,\n  // but ShadyCSS patches define directly.\n  window.customElements.define = define;\n  // Still patch the registry directly since Safari 10 loses the patch\n  // unless this is done.\n  Object.defineProperty(window['CustomElementRegistry'].prototype, 'define', {\n    value: define,\n    configurable: true,\n  });\n}\n\n/** @return {!ShadyRoot|undefined} */\nexport const ownerShadyRootForNode = (node) => {\n  let root = node[utils.SHADY_PREFIX + 'getRootNode']();\n  if (utils.isShadyRoot(root)) {\n    return root;\n  }\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\nimport {shadyDataForNode} from '../shady-data.js';\n\nexport const SlotablePatches = utils.getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get assignedSlot() {\n    // Force any parent's shadowRoot to flush so that distribution occurs\n    // and this node has an assignedSlot.\n    const parent = this[utils.SHADY_PREFIX + 'parentNode'];\n    const ownerRoot = parent && parent[utils.SHADY_PREFIX + 'shadowRoot'];\n    if (ownerRoot) {\n      ownerRoot._render();\n    }\n    const nodeData = shadyDataForNode(this);\n    return (nodeData && nodeData.assignedSlot) || null;\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\nimport {shadyDataForNode} from '../shady-data.js';\n\n/**\n * @param {Node} node\n * @param {Function} matcher\n * @param {Function=} halter\n */\nexport function query(node, matcher, halter) {\n  let list = [];\n  queryChildNodes(node, matcher, halter, list);\n  return list;\n}\n\nfunction queryChildNodes(parent, matcher, halter, list) {\n  for (\n    let n = parent[utils.SHADY_PREFIX + 'firstChild'];\n    n;\n    n = n[utils.SHADY_PREFIX + 'nextSibling']\n  ) {\n    if (\n      n.nodeType === Node.ELEMENT_NODE &&\n      queryElement(n, matcher, halter, list)\n    ) {\n      return true;\n    }\n  }\n}\n\nfunction queryElement(node, matcher, halter, list) {\n  let result = matcher(node);\n  if (result) {\n    list.push(node);\n  }\n  if (halter && halter(result)) {\n    return result;\n  }\n  queryChildNodes(node, matcher, halter, list);\n}\n\n// Needed on Element, DocumentFragment, Document\nexport const ParentNodePatches = utils.getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get firstElementChild() {\n    const nodeData = shadyDataForNode(this);\n    if (nodeData && nodeData.firstChild !== undefined) {\n      let n = this[utils.SHADY_PREFIX + 'firstChild'];\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[utils.SHADY_PREFIX + 'nextSibling'];\n      }\n      return n;\n    } else {\n      return this[utils.NATIVE_PREFIX + 'firstElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get lastElementChild() {\n    const nodeData = shadyDataForNode(this);\n    if (nodeData && nodeData.lastChild !== undefined) {\n      let n = this[utils.SHADY_PREFIX + 'lastChild'];\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[utils.SHADY_PREFIX + 'previousSibling'];\n      }\n      return n;\n    } else {\n      return this[utils.NATIVE_PREFIX + 'lastElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get children() {\n    if (!utils.isTrackingLogicalChildNodes(this)) {\n      return this[utils.NATIVE_PREFIX + 'children'];\n    }\n    return utils.createPolyfilledHTMLCollection(\n      Array.prototype.filter.call(utils.childNodesArray(this), (n) => {\n        return n.nodeType === Node.ELEMENT_NODE;\n      })\n    );\n  },\n\n  /** @this {Element} */\n  get childElementCount() {\n    let children = this[utils.SHADY_PREFIX + 'children'];\n    if (children) {\n      return children.length;\n    }\n    return 0;\n  },\n\n  /** @this {Element} */\n  append(...args) {\n    this[utils.SHADY_PREFIX + 'insertBefore'](\n      utils.convertNodesIntoANode(...args),\n      null\n    );\n  },\n\n  /** @this {Element} */\n  prepend(...args) {\n    this[utils.SHADY_PREFIX + 'insertBefore'](\n      utils.convertNodesIntoANode(...args),\n      this[utils.SHADY_PREFIX + 'firstChild']\n    );\n  },\n\n  /** @this {Element} */\n  ['replaceChildren'](...args) {\n    let child;\n    while ((child = this[utils.SHADY_PREFIX + 'firstChild']) !== null) {\n      this[utils.SHADY_PREFIX + 'removeChild'](child);\n    }\n    this[utils.SHADY_PREFIX + 'insertBefore'](\n      utils.convertNodesIntoANode(...args),\n      null\n    );\n  },\n});\n\nexport const QueryPatches = utils.getOwnPropertyDescriptors({\n  // TODO(sorvell): consider doing native QSA and filtering results.\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   */\n  querySelector(selector) {\n    // match selector and halt on first result.\n    let result = query(\n      this,\n      function (n) {\n        return utils.matchesSelector(n, selector);\n      },\n      function (n) {\n        return Boolean(n);\n      }\n    )[0];\n    return result || null;\n  },\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   * @param  {boolean} useNative\n   */\n  // TODO(sorvell): `useNative` option relies on native querySelectorAll and\n  // misses distributed nodes, see\n  // https://github.com/webcomponents/shadydom/pull/210#issuecomment-361435503\n  querySelectorAll(selector, useNative) {\n    if (useNative) {\n      const o = Array.prototype.slice.call(\n        this[utils.NATIVE_PREFIX + 'querySelectorAll'](selector)\n      );\n      const root = this[utils.SHADY_PREFIX + 'getRootNode']();\n      return utils.createPolyfilledHTMLCollection(\n        o.filter((e) => e[utils.SHADY_PREFIX + 'getRootNode']() == root)\n      );\n    }\n    return utils.createPolyfilledHTMLCollection(\n      query(this, function (n) {\n        return utils.matchesSelector(n, selector);\n      })\n    );\n  },\n});\n\n// In preferPerformance mode, create a custom `ParentNodeDocumentOrFragment`\n// that optionally does not mixin querySelector/All; this is a performance\n// optimization. In noPatch, we need to keep the query patches here in order to\n// ensure the query API is available on the wrapper\nexport const ParentNodeDocumentOrFragmentPatches =\n  utils.settings.preferPerformance && !utils.settings.noPatch\n    ? utils.assign({}, ParentNodePatches)\n    : ParentNodePatches;\n\nutils.assign(ParentNodePatches, QueryPatches);\n","/**\n@license\nCopyright (c) 2020 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\n\nexport const ChildNodePatches = utils.getOwnPropertyDescriptors({\n  /** @this {Element} */\n  after(...args) {\n    const parentNode = this[utils.SHADY_PREFIX + 'parentNode'];\n    if (parentNode === null) {\n      return;\n    }\n    const nextSibling = this[utils.SHADY_PREFIX + 'nextSibling'];\n    parentNode[utils.SHADY_PREFIX + 'insertBefore'](\n      utils.convertNodesIntoANode(...args),\n      nextSibling\n    );\n  },\n\n  /** @this {Element} */\n  before(...args) {\n    const parentNode = this[utils.SHADY_PREFIX + 'parentNode'];\n    if (parentNode === null) {\n      return;\n    }\n    parentNode[utils.SHADY_PREFIX + 'insertBefore'](\n      utils.convertNodesIntoANode(...args),\n      this\n    );\n  },\n\n  /** @this {Element} */\n  remove() {\n    const parentNode = this[utils.SHADY_PREFIX + 'parentNode'];\n    if (parentNode === null) {\n      return;\n    }\n    parentNode[utils.SHADY_PREFIX + 'removeChild'](this);\n  },\n\n  /** @this {Element} */\n  replaceWith(...args) {\n    const parentNode = this[utils.SHADY_PREFIX + 'parentNode'];\n    if (parentNode === null) {\n      return;\n    }\n    const nextSibling = this[utils.SHADY_PREFIX + 'nextSibling'];\n    parentNode[utils.SHADY_PREFIX + 'removeChild'](this);\n    parentNode[utils.SHADY_PREFIX + 'insertBefore'](\n      utils.convertNodesIntoANode(...args),\n      nextSibling\n    );\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\nimport {scopeClassAttribute} from '../style-scoping.js';\nimport {shadyDataForNode} from '../shady-data.js';\nimport {attachShadow, ownerShadyRootForNode} from '../attach-shadow.js';\n// prettier-ignore\nimport {eventPropertyNamesForElement, wrappedDescriptorForEventProperty} from '../patch-events.js';\n\nconst doc = window.document;\n\n/**\n * Should be called whenever an attribute changes. If the `slot` attribute\n * changes, provokes rendering if necessary. If a `<slot>` element's `name`\n * attribute changes, updates the root's slot map and renders.\n * @param {Node} node\n * @param {string} name\n */\nfunction distributeAttributeChange(node, name) {\n  if (name === 'slot') {\n    const parent = node[utils.SHADY_PREFIX + 'parentNode'];\n    if (utils.hasShadowRootWithSlot(parent)) {\n      shadyDataForNode(parent).root._asyncRender();\n    }\n  } else if (node.localName === 'slot' && name === 'name') {\n    let root = ownerShadyRootForNode(node);\n    if (root) {\n      root._updateSlotName(node);\n      root._asyncRender();\n    }\n  }\n}\n\nexport const ElementPatches = utils.getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get previousElementSibling() {\n    const nodeData = shadyDataForNode(this);\n    if (nodeData && nodeData.previousSibling !== undefined) {\n      let n = this[utils.SHADY_PREFIX + 'previousSibling'];\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[utils.SHADY_PREFIX + 'previousSibling'];\n      }\n      return n;\n    } else {\n      return this[utils.NATIVE_PREFIX + 'previousElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get nextElementSibling() {\n    const nodeData = shadyDataForNode(this);\n    if (nodeData && nodeData.nextSibling !== undefined) {\n      let n = this[utils.SHADY_PREFIX + 'nextSibling'];\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[utils.SHADY_PREFIX + 'nextSibling'];\n      }\n      return n;\n    } else {\n      return this[utils.NATIVE_PREFIX + 'nextElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get slot() {\n    return this.getAttribute('slot');\n  },\n\n  /** @this {Element} */\n  set slot(value) {\n    this[utils.SHADY_PREFIX + 'setAttribute']('slot', value);\n  },\n\n  /** @this {Element} */\n  get className() {\n    return this.getAttribute('class') || '';\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set className(value) {\n    this[utils.SHADY_PREFIX + 'setAttribute']('class', value);\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   * @param {string} value\n   */\n  setAttribute(attr, value) {\n    if (this.ownerDocument !== doc) {\n      this[utils.NATIVE_PREFIX + 'setAttribute'](attr, value);\n    } else if (!scopeClassAttribute(this, attr, value)) {\n      this[utils.NATIVE_PREFIX + 'setAttribute'](attr, value);\n      distributeAttributeChange(this, attr);\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   */\n  removeAttribute(attr) {\n    if (this.ownerDocument !== doc) {\n      this[utils.NATIVE_PREFIX + 'removeAttribute'](attr);\n    } else if (!scopeClassAttribute(this, attr, '')) {\n      this[utils.NATIVE_PREFIX + 'removeAttribute'](attr);\n      distributeAttributeChange(this, attr);\n    } else if (this.getAttribute(attr) === '') {\n      // ensure that \"class\" attribute is fully removed if ShadyCSS does not keep scoping\n      this[utils.NATIVE_PREFIX + 'removeAttribute'](attr);\n    }\n  },\n});\n\nif (!utils.settings.preferPerformance) {\n  eventPropertyNamesForElement.forEach((property) => {\n    ElementPatches[property] = wrappedDescriptorForEventProperty(property);\n  });\n}\n\nexport const ElementShadowPatches = utils.getOwnPropertyDescriptors({\n  /**\n   * @this {Element}\n   * @param {!{mode: string}} options\n   */\n  attachShadow(options) {\n    const root = attachShadow(this, options);\n    // TODO(sorvell): Workaround for CE not seeing shadowRoot in `on-demand`\n    // noPatch mode. CE's attachShadow patch is overwritten by this patch\n    // and cannot set its own special tracking for shadowRoot. It does this\n    // to be able to see closed shadowRoots.\n    // This is necessary so that the CE polyfill can traverse into nodes\n    // with shadowRoot that will under `on-demand` have their childNodes patched.\n    this['__CE_shadowRoot'] = root;\n    return root;\n  },\n\n  // Note: Can be patched on element prototype on all browsers.\n  // Must be patched on instance on browsers that support native Shadow DOM\n  // but do not have builtin accessors (old Chrome).\n  /** @this {Element} */\n  get shadowRoot() {\n    const nodeData = shadyDataForNode(this);\n    return (nodeData && nodeData.publicRoot) || null;\n  },\n});\n\nutils.assign(ElementPatches, ElementShadowPatches);\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\nimport {getInnerHTML} from '../innerHTML.js';\nimport {clearNode} from './Node.js';\n\n/** @type {!Document} */\nconst inertDoc = document.implementation.createHTMLDocument('inert');\n\nexport const ElementOrShadowRootPatches = utils.getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get innerHTML() {\n    if (utils.isTrackingLogicalChildNodes(this)) {\n      const content =\n        this.localName === 'template'\n          ? /** @type {HTMLTemplateElement} */ (this).content\n          : this;\n      return getInnerHTML(content, utils.childNodesArray);\n    } else {\n      return this[utils.NATIVE_PREFIX + 'innerHTML'];\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set innerHTML(value) {\n    if (this.localName === 'template') {\n      this[utils.NATIVE_PREFIX + 'innerHTML'] = value;\n    } else {\n      clearNode(this);\n      const containerName = this.localName || 'div';\n      let htmlContainer;\n      if (!this.namespaceURI || this.namespaceURI === inertDoc.namespaceURI) {\n        htmlContainer = inertDoc.createElement(containerName);\n      } else {\n        htmlContainer = inertDoc.createElementNS(\n          this.namespaceURI,\n          containerName\n        );\n      }\n      if (utils.settings.hasDescriptors) {\n        htmlContainer[utils.NATIVE_PREFIX + 'innerHTML'] = value;\n      } else {\n        htmlContainer.innerHTML = value;\n      }\n      let firstChild;\n      while ((firstChild = htmlContainer[utils.SHADY_PREFIX + 'firstChild'])) {\n        this[utils.SHADY_PREFIX + 'insertBefore'](firstChild);\n      }\n    }\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\n// prettier-ignore\nimport {eventPropertyNamesForHTMLElement, wrappedDescriptorForEventProperty} from '../patch-events.js';\nimport {shadyDataForNode} from '../shady-data.js';\n\nexport const HTMLElementPatches = utils.getOwnPropertyDescriptors({\n  /** @this {HTMLElement} */\n  blur() {\n    const nodeData = shadyDataForNode(this);\n    let root = nodeData && nodeData.root;\n    let shadowActive = root && root.activeElement;\n    if (shadowActive) {\n      shadowActive[utils.SHADY_PREFIX + 'blur']();\n    } else {\n      this[utils.NATIVE_PREFIX + 'blur']();\n    }\n  },\n});\n\nif (!utils.settings.preferPerformance) {\n  eventPropertyNamesForHTMLElement.forEach((property) => {\n    HTMLElementPatches[property] = wrappedDescriptorForEventProperty(property);\n  });\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\nimport {shadyDataForNode} from '../shady-data.js';\nimport {addEventListener, removeEventListener} from '../patch-events.js';\n\nexport const SlotPatches = utils.getOwnPropertyDescriptors({\n  /**\n   * @this {HTMLSlotElement}\n   * @param {Object=} options\n   */\n  assignedNodes(options) {\n    if (this.localName === 'slot') {\n      // Force any containing shadowRoot to flush so that distribution occurs\n      // and this node has assignedNodes.\n      const root = this[utils.SHADY_PREFIX + 'getRootNode']();\n      if (root && utils.isShadyRoot(root)) {\n        root._render();\n      }\n      const nodeData = shadyDataForNode(this);\n      return nodeData\n        ? (options && options.flatten\n            ? nodeData.flattenedNodes\n            : nodeData.assignedNodes) || []\n        : [];\n    }\n  },\n\n  /**\n   * @this {HTMLSlotElement}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener(type, fn, optionsOrCapture) {\n    // NOTE, check if this is a `slot` because these patches are installed on\n    // Element where browsers don't have `<slot>`\n    if (this.localName !== 'slot' || type === 'slotchange') {\n      addEventListener.call(this, type, fn, optionsOrCapture);\n    } else {\n      if (typeof optionsOrCapture !== 'object') {\n        optionsOrCapture = {\n          capture: Boolean(optionsOrCapture),\n        };\n      }\n      const parent = this[utils.SHADY_PREFIX + 'parentNode'];\n      if (!parent) {\n        throw new Error(\n          'ShadyDOM cannot attach event to slot unless it has a `parentNode`'\n        );\n      }\n      optionsOrCapture.__shadyTarget = this;\n      parent[utils.SHADY_PREFIX + 'addEventListener'](\n        type,\n        fn,\n        optionsOrCapture\n      );\n    }\n  },\n\n  /**\n   * @this {HTMLSlotElement}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener(type, fn, optionsOrCapture) {\n    // NOTE, check if this is a `slot` because these patches are installed on\n    // Element where browsers don't have `<slot>`\n    if (this.localName !== 'slot' || type === 'slotchange') {\n      removeEventListener.call(this, type, fn, optionsOrCapture);\n    } else {\n      if (typeof optionsOrCapture !== 'object') {\n        optionsOrCapture = {\n          capture: Boolean(optionsOrCapture),\n        };\n      }\n      const parent = this[utils.SHADY_PREFIX + 'parentNode'];\n      if (!parent) {\n        throw new Error(\n          'ShadyDOM cannot attach event to slot unless it has a `parentNode`'\n        );\n      }\n      optionsOrCapture.__shadyTarget = this;\n      parent[utils.SHADY_PREFIX + 'removeEventListener'](\n        type,\n        fn,\n        optionsOrCapture\n      );\n    }\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport * as utils from '../utils.js';\nimport {query} from './ParentNode.js';\n\nexport const DocumentOrFragmentPatches = utils.getOwnPropertyDescriptors({\n  /**\n   * @this {Element}\n   * @param {string} id\n   */\n  getElementById(id) {\n    if (id === '') {\n      return null;\n    }\n    let result = query(\n      this,\n      function (n) {\n        return n.id == id;\n      },\n      function (n) {\n        return Boolean(n);\n      }\n    )[0];\n    return result || null;\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\nimport {ownerShadyRootForNode} from '../attach-shadow.js';\n\nfunction getDocumentActiveElement() {\n  if (utils.settings.hasDescriptors) {\n    return document[utils.NATIVE_PREFIX + 'activeElement'];\n  } else {\n    return document.activeElement;\n  }\n}\n\n// Get the element within the given set of roots.\nfunction getElInRoot(roots, el) {\n  let elRoot;\n  while (\n    el &&\n    !roots.has((elRoot = el[utils.SHADY_PREFIX + 'getRootNode']()))\n  ) {\n    el = elRoot.host;\n  }\n  return el;\n}\n\nfunction getAncestorRoots(docOrRoot) {\n  const roots = new Set();\n  roots.add(docOrRoot);\n  while (utils.isShadyRoot(docOrRoot) && docOrRoot.host) {\n    docOrRoot = docOrRoot.host[utils.SHADY_PREFIX + 'getRootNode']();\n    roots.add(docOrRoot);\n  }\n  return roots;\n}\n\nconst elementsFromPointProperty =\n  utils.NATIVE_PREFIX +\n  utils.getPropertyName(Document.prototype, 'elementsFromPoint');\n\nexport const DocumentOrShadowRootPatches = utils.getOwnPropertyDescriptors({\n  /** @this {Document|ShadowRoot} */\n  get activeElement() {\n    let active = getDocumentActiveElement();\n    // In IE11, activeElement might be an empty object if the document is\n    // contained in an iframe.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/\n    if (!active || !active.nodeType) {\n      return null;\n    }\n    let isShadyRoot = !!utils.isShadyRoot(this);\n    if (this !== document) {\n      // If this node isn't a document or shady root, then it doesn't have\n      // an active element.\n      if (!isShadyRoot) {\n        return null;\n      }\n      // If this shady root's host is the active element or the active\n      // element is not a descendant of the host (in the composed tree),\n      // then it doesn't have an active element.\n      if (\n        this.host === active ||\n        !this.host[utils.NATIVE_PREFIX + 'contains'](active)\n      ) {\n        return null;\n      }\n    }\n    // This node is either the document or a shady root of which the active\n    // element is a (composed) descendant of its host; iterate upwards to\n    // find the active element's most shallow host within it.\n    let activeRoot = ownerShadyRootForNode(active);\n    while (activeRoot && activeRoot !== this) {\n      active = activeRoot.host;\n      activeRoot = ownerShadyRootForNode(active);\n    }\n    if (this === document) {\n      // This node is the document, so activeRoot should be null.\n      return activeRoot ? null : active;\n    } else {\n      // This node is a non-document shady root, and it should be\n      // activeRoot.\n      return activeRoot === this ? active : null;\n    }\n  },\n\n  /** @this {Document|ShadowRoot} */\n  elementsFromPoint(x, y) {\n    const nativeResult = utils.arrayFrom(\n      document[elementsFromPointProperty](x, y)\n    );\n    // Filter native result to return the element in this root\n    // OR an above root.\n    // Set containing this root and its ancestor roots.\n    const ancestorRoots = getAncestorRoots(this);\n    // Use a Set since the elements can repeat.\n    const rootedResult = new Set();\n    for (let i = 0; i < nativeResult.length; i++) {\n      rootedResult.add(getElInRoot(ancestorRoots, nativeResult[i]));\n    }\n    // Note, for IE compat avoid Array.from(set).\n    const r = [];\n    rootedResult.forEach((x) => r.push(x));\n    return r;\n  },\n\n  /** @this {Document|ShadowRoot} */\n  elementFromPoint(x, y) {\n    return this[utils.SHADY_PREFIX + 'elementsFromPoint'](x, y)[0] || null;\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\n\nconst doc = window.document;\n\nexport const DocumentPatches = utils.getOwnPropertyDescriptors({\n  // note: Though not technically correct, we fast path `importNode`\n  // when called on a node not owned by the main document.\n  // This allows, for example, elements that cannot\n  // contain custom elements and are therefore not likely to contain shadowRoots\n  // to cloned natively. This is a fairly significant performance win.\n  /**\n   * @this {Document}\n   * @param {Node} node\n   * @param {boolean} deep\n   */\n  importNode(node, deep) {\n    // A template element normally has no children with shadowRoots, so make\n    // sure we always make a deep copy to correctly construct the template.content\n    if (node.ownerDocument !== doc || node.localName === 'template') {\n      return this[utils.NATIVE_PREFIX + 'importNode'](node, deep);\n    }\n    let n = this[utils.NATIVE_PREFIX + 'importNode'](node, false);\n    if (deep) {\n      for (\n        let c = node[utils.SHADY_PREFIX + 'firstChild'], nc;\n        c;\n        c = c[utils.SHADY_PREFIX + 'nextSibling']\n      ) {\n        nc = this[utils.SHADY_PREFIX + 'importNode'](c, true);\n        n[utils.SHADY_PREFIX + 'appendChild'](nc);\n      }\n    }\n    return n;\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport * as utils from '../utils.js';\n// prettier-ignore\nimport {addEventListener, removeEventListener, dispatchEvent} from '../patch-events.js';\n\nexport const WindowPatches = utils.getOwnPropertyDescriptors({\n  // Ensure that `dispatchEvent` is patched directly on Window since on\n  // IE11, Window does not descend from EventTarget.\n  dispatchEvent,\n\n  // NOTE: ensure these methods are bound to `window` so that `this` is correct\n  // when called directly from global context without a receiver; e.g.\n  // `addEventListener(...)`.\n  addEventListener: addEventListener.bind(window),\n\n  removeEventListener: removeEventListener.bind(window),\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {EventTargetPatches} from './patches/EventTarget.js';\nimport {NodePatches} from './patches/Node.js';\nimport {SlotablePatches} from './patches/Slotable.js';\n// prettier-ignore\nimport {ParentNodePatches, ParentNodeDocumentOrFragmentPatches} from './patches/ParentNode.js';\nimport {ChildNodePatches} from './patches/ChildNode.js';\nimport {ElementPatches, ElementShadowPatches} from './patches/Element.js';\nimport {ElementOrShadowRootPatches} from './patches/ElementOrShadowRoot.js';\nimport {HTMLElementPatches} from './patches/HTMLElement.js';\nimport {SlotPatches} from './patches/Slot.js';\nimport {DocumentOrFragmentPatches} from './patches/DocumentOrFragment.js';\nimport {DocumentOrShadowRootPatches} from './patches/DocumentOrShadowRoot.js';\nimport {DocumentPatches} from './patches/Document.js';\nimport {WindowPatches} from './patches/Window.js';\n\n// Some browsers (IE/Edge) have non-standard HTMLElement accessors.\nconst NonStandardHTMLElement = {};\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement')) {\n  NonStandardHTMLElement.parentElement = NodePatches.parentElement;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'contains')) {\n  NonStandardHTMLElement.contains = NodePatches.contains;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'children')) {\n  NonStandardHTMLElement.children = ParentNodePatches.children;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML')) {\n  NonStandardHTMLElement.innerHTML = ElementOrShadowRootPatches.innerHTML;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'className')) {\n  NonStandardHTMLElement.className = ElementPatches.className;\n}\n\n// Avoid patching `innerHTML` if it does not exist on Element (IE)\n// and we can patch accessors (hasDescriptors).\nconst ElementShouldHaveInnerHTML =\n  !utils.settings.hasDescriptors || 'innerHTML' in Element.prototype;\n\n// setup patching\nconst patchMap = {\n  EventTarget: [EventTargetPatches],\n  Node: [NodePatches, !window.EventTarget ? EventTargetPatches : null],\n  Text: [SlotablePatches],\n  Comment: [SlotablePatches],\n  CDATASection: [SlotablePatches],\n  ProcessingInstruction: [SlotablePatches],\n  Element: [\n    ElementPatches,\n    ParentNodePatches,\n    ChildNodePatches,\n    SlotablePatches,\n    ElementShouldHaveInnerHTML ? ElementOrShadowRootPatches : null,\n    !window.HTMLSlotElement ? SlotPatches : null,\n  ],\n  HTMLElement: [HTMLElementPatches, NonStandardHTMLElement],\n  HTMLSlotElement: [SlotPatches],\n  DocumentFragment: [\n    ParentNodeDocumentOrFragmentPatches,\n    DocumentOrFragmentPatches,\n  ],\n  Document: [\n    DocumentPatches,\n    ParentNodeDocumentOrFragmentPatches,\n    DocumentOrFragmentPatches,\n    DocumentOrShadowRootPatches,\n  ],\n  Window: [WindowPatches],\n  CharacterData: [ChildNodePatches],\n};\n\nconst getPatchPrototype = (name) => window[name] && window[name].prototype;\n\n// Note, must avoid patching accessors on prototypes when descriptors are not correct\n// because the CustomElements polyfill checks if these exist before patching instances.\n// CustomElements polyfill *only* cares about these accessors.\nconst disallowedNativePatches = utils.settings.hasDescriptors\n  ? null\n  : ['innerHTML', 'textContent'];\n\n/**\n * Patch a group of accessors on an object.\n * @param {!Object} proto\n * @param {!Array<Object>} list\n * @param {string=} prefix\n * @param {Array=} disallowed\n */\nfunction applyPatchList(proto, list, prefix, disallowed) {\n  list.forEach(\n    (patch) =>\n      proto && patch && utils.patchProperties(proto, patch, prefix, disallowed)\n  );\n}\n\n/** @param {string=} prefix */\nexport const applyPatches = (prefix) => {\n  const disallowed = prefix ? null : disallowedNativePatches;\n  for (let p in patchMap) {\n    const proto = getPatchPrototype(p);\n    applyPatchList(proto, patchMap[p], prefix, disallowed);\n  }\n};\n\nconst PROTO_IS_PATCHED = utils.SHADY_PREFIX + 'protoIsPatched';\n\n// This property is stored directly on these objects, rather than in a local\n// Map, because IE11 has a bug around `defineProperty`/`hasOwnProperty` which\n// breaks Closure Compiler's WeakMap polyfill when using both certain native\n// prototypes (e.g. of CDATASection) and their instances as keys - even if\n// they're isolated to different WeakMaps. Closure's WeakMap polyfill is used\n// transitively by its own Map and Set polyfills, so this bug applies to any\n// situation where either of Map or Set are polyfilled also.\nconst PATCHED_PROTO = utils.SHADY_PREFIX + 'patchedProto';\n\n// Patch non-element prototypes up front so that we don't have to check\n// the type of Node when patching an can always assume we're patching an element.\n['Text', 'Comment', 'CDATASection', 'ProcessingInstruction'].forEach((name) => {\n  const ctor = window[name];\n  const patchedProto = Object.create(ctor.prototype);\n  patchedProto[PROTO_IS_PATCHED] = true;\n  applyPatchList(patchedProto, patchMap.EventTarget);\n  applyPatchList(patchedProto, patchMap.Node);\n  if (patchMap[name]) {\n    applyPatchList(patchedProto, patchMap[name]);\n  }\n  ctor.prototype[PATCHED_PROTO] = patchedProto;\n});\n\nexport const patchElementProto = (proto) => {\n  proto[PROTO_IS_PATCHED] = true;\n  applyPatchList(proto, patchMap.EventTarget);\n  applyPatchList(proto, patchMap.Node);\n  applyPatchList(proto, patchMap.Element);\n  applyPatchList(proto, patchMap.HTMLElement);\n  applyPatchList(proto, patchMap.HTMLSlotElement);\n  return proto;\n};\n\nexport const patchNodeProto = (node) => {\n  if (node[PROTO_IS_PATCHED] || utils.isShadyRoot(node)) {\n    return;\n  }\n  const nativeProto = Object.getPrototypeOf(node);\n  // Note, this hasOwnProperty check is critical to avoid seeing a patched\n  // prototype lower in the prototype chain, e.g. if an <s> element has been\n  // patched, without this check, an <input> element would get the wrong patch.\n  let proto =\n    nativeProto.hasOwnProperty(PATCHED_PROTO) && nativeProto[PATCHED_PROTO];\n  if (!proto) {\n    proto = Object.create(nativeProto);\n    patchElementProto(proto);\n    nativeProto[PATCHED_PROTO] = proto;\n  }\n  Object.setPrototypeOf(node, proto);\n};\n\nexport const patchShadowOnElement = () => {\n  utils.patchProperties(Element.prototype, ElementShadowPatches);\n};\n\nexport const addShadyPrefixedProperties = () => {\n  // perform shady patches\n  applyPatches(utils.SHADY_PREFIX);\n\n  // install `_activeElement` because some browsers (older Chrome/Safari) do not have\n  // a 'configurable' `activeElement` accesssor.\n  const descriptor = DocumentOrShadowRootPatches.activeElement;\n  Object.defineProperty(document, '_activeElement', descriptor);\n\n  // On Window, we're patching `addEventListener` which is a weird auto-bound\n  // property that is not directly on the Window prototype.\n  utils.patchProperties(Window.prototype, WindowPatches, utils.SHADY_PREFIX);\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {shadyDataForNode, ensureShadyDataForNode} from './shady-data.js';\n// prettier-ignore\nimport {patchInsideElementAccessors, patchOutsideElementAccessors} from './patch-instances.js';\nimport {patchNodeProto} from './patch-prototypes.js';\n\nconst OutsideAccessors = 1;\nconst InsideAcccessors = 2;\n\nconst patchOnDemand = utils.settings.patchOnDemand;\nconst hasDescriptors = utils.settings.hasDescriptors;\n\nfunction patchNode(node, type) {\n  if (patchOnDemand) {\n    patchNodeProto(node);\n  }\n  if (!hasDescriptors) {\n    if (type === OutsideAccessors) {\n      patchOutsideElementAccessors(node);\n    } else if (type === InsideAcccessors) {\n      patchInsideElementAccessors(node);\n    }\n  }\n}\n\nfunction linkNode(node, container, containerData, ref_node) {\n  patchNode(node, OutsideAccessors);\n  ref_node = ref_node || null;\n  const nodeData = ensureShadyDataForNode(node);\n  const ref_nodeData = ref_node ? ensureShadyDataForNode(ref_node) : null;\n  // update ref_node.previousSibling <-> node\n  nodeData.previousSibling = ref_node\n    ? ref_nodeData.previousSibling\n    : container[utils.SHADY_PREFIX + 'lastChild'];\n  let psd = shadyDataForNode(nodeData.previousSibling);\n  if (psd) {\n    psd.nextSibling = node;\n  }\n  // update node <-> ref_node\n  let nsd = shadyDataForNode((nodeData.nextSibling = ref_node));\n  if (nsd) {\n    nsd.previousSibling = node;\n  }\n  // update node <-> container\n  nodeData.parentNode = container;\n  if (ref_node) {\n    if (ref_node === containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } else {\n    containerData.lastChild = node;\n    if (!containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  }\n  // remove caching of childNodes\n  containerData.childNodes = null;\n}\n\nexport const recordInsertBefore = (node, container, ref_node) => {\n  patchNode(container, InsideAcccessors);\n  const containerData = ensureShadyDataForNode(container);\n  if (containerData.firstChild !== undefined) {\n    containerData.childNodes = null;\n  }\n  // handle document fragments\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // Note, documentFragments should not have logical DOM so there's\n    // no need update that. It is possible to append a ShadowRoot, but we're\n    // choosing not to support that.\n    const first = node[utils.NATIVE_PREFIX + 'firstChild'];\n    for (let n = first; n; n = n[utils.NATIVE_PREFIX + 'nextSibling']) {\n      linkNode(n, container, containerData, ref_node);\n    }\n  } else {\n    linkNode(node, container, containerData, ref_node);\n  }\n};\n\nexport const recordRemoveChild = (node, container) => {\n  const nodeData = ensureShadyDataForNode(node);\n  const containerData = ensureShadyDataForNode(container);\n  if (node === containerData.firstChild) {\n    containerData.firstChild = nodeData.nextSibling;\n  }\n  if (node === containerData.lastChild) {\n    containerData.lastChild = nodeData.previousSibling;\n  }\n  let p = nodeData.previousSibling;\n  let n = nodeData.nextSibling;\n  if (p) {\n    ensureShadyDataForNode(p).nextSibling = n;\n  }\n  if (n) {\n    ensureShadyDataForNode(n).previousSibling = p;\n  }\n  // When an element is removed, logical data is no longer tracked.\n  // Explicitly set `undefined` here to indicate this. This is disginguished\n  // from `null` which is set if info is null.\n  nodeData.parentNode = nodeData.previousSibling = nodeData.nextSibling = undefined;\n  if (containerData.childNodes !== undefined) {\n    // remove caching of childNodes\n    containerData.childNodes = null;\n  }\n};\n\n/**\n * @param  {!Node|DocumentFragment} node\n * @param  {!Node|DocumentFragment=} adoptedParent\n */\nexport const recordChildNodes = (node, adoptedParent) => {\n  const nodeData = ensureShadyDataForNode(node);\n  if (!adoptedParent && nodeData.firstChild !== undefined) {\n    return;\n  }\n  // remove caching of childNodes\n  nodeData.childNodes = null;\n  const first = (nodeData.firstChild =\n    node[utils.NATIVE_PREFIX + 'firstChild']);\n  nodeData.lastChild = node[utils.NATIVE_PREFIX + 'lastChild'];\n  patchNode(node, InsideAcccessors);\n  for (let n = first, previous; n; n = n[utils.NATIVE_PREFIX + 'nextSibling']) {\n    const sd = ensureShadyDataForNode(n);\n    sd.parentNode = adoptedParent || node;\n    sd.nextSibling = n[utils.NATIVE_PREFIX + 'nextSibling'];\n    sd.previousSibling = previous || null;\n    previous = n;\n    patchNode(n, OutsideAccessors);\n  }\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from '../utils.js';\n\nexport const ShadowRootPatches = utils.getOwnPropertyDescriptors({\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener(type, fn, optionsOrCapture) {\n    if (typeof optionsOrCapture !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture),\n      };\n    }\n    // Note, `__shadyTarget` may already be set if an event was added on a <slot> child\n    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;\n    this.host[utils.SHADY_PREFIX + 'addEventListener'](\n      type,\n      fn,\n      optionsOrCapture\n    );\n  },\n\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener(type, fn, optionsOrCapture) {\n    if (typeof optionsOrCapture !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture),\n      };\n    }\n    // Note, `__shadyTarget` may already be set if an event was added on a <slot> child\n    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;\n    this.host[utils.SHADY_PREFIX + 'removeEventListener'](\n      type,\n      fn,\n      optionsOrCapture\n    );\n  },\n});\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\nimport {NodePatches} from './patches/Node.js';\n// prettier-ignore\nimport {OutsideDescriptors, InsideDescriptors, TextContentInnerHTMLDescriptors} from './patch-instances.js';\nimport {ParentNodePatches} from './patches/ParentNode.js';\nimport {DocumentOrFragmentPatches} from './patches/DocumentOrFragment.js';\nimport {DocumentOrShadowRootPatches} from './patches/DocumentOrShadowRoot.js';\nimport {ElementOrShadowRootPatches} from './patches/ElementOrShadowRoot.js';\nimport {ShadowRootPatches} from './patches/ShadowRoot.js';\n\n/**\n * @param {!Object} proto\n * @param {string=} prefix\n */\nconst patchShadyAccessors = (proto, prefix) => {\n  utils.patchProperties(proto, ShadowRootPatches, prefix);\n  utils.patchProperties(proto, DocumentOrShadowRootPatches, prefix);\n  utils.patchProperties(proto, ElementOrShadowRootPatches, prefix);\n  // We ensure ParentNode accessors since these do not exist in Edge/IE on DocumentFragments.\n  utils.patchProperties(proto, ParentNodePatches, prefix);\n  // Ensure `shadowRoot` has basic descriptors when we cannot rely\n  // on them coming from DocumentFragment.\n  //\n  // Case 1, noPatching: Because we want noPatch ShadyRoots to have native property\n  // names so that they do not have to be wrapped...\n  // When we do *not* patch Node/DocumentFragment.prototype\n  // we must manually install those properties on ShadyRoot's prototype.\n  // Note, it's important to only install these in this mode so as not to stomp\n  // over CustomElements polyfill's patches on Node/DocumentFragment methods.\n  if (utils.settings.noPatch && !prefix) {\n    utils.patchProperties(proto, NodePatches, prefix);\n    utils.patchProperties(proto, DocumentOrFragmentPatches, prefix);\n  }\n  // Case 2, bad descriptors: Ensure accessors are on ShadowRoot.\n  // These descriptors are normally used for instance patching but because\n  // ShadyRoot can always be patched, just do it to the prototype.\n  else if (!utils.settings.hasDescriptors) {\n    utils.patchProperties(proto, OutsideDescriptors);\n    utils.patchProperties(proto, InsideDescriptors);\n    utils.patchProperties(proto, TextContentInnerHTMLDescriptors);\n  }\n};\n\nexport const patchShadyRoot = (proto) => {\n  proto.__proto__ = DocumentFragment.prototype;\n\n  // patch both prefixed and not, even when noPatch == true.\n  patchShadyAccessors(proto, utils.SHADY_PREFIX);\n  patchShadyAccessors(proto);\n\n  // Ensure native properties are all safely wrapped since ShadowRoot is not an\n  // actual DocumentFragment instance.\n  Object.defineProperties(proto, {\n    nodeType: {\n      value: Node.DOCUMENT_FRAGMENT_NODE,\n      configurable: true,\n    },\n    nodeName: {\n      value: '#document-fragment',\n      configurable: true,\n    },\n    nodeValue: {\n      value: null,\n      configurable: true,\n    },\n  });\n\n  // make undefined\n  ['localName', 'namespaceURI', 'prefix'].forEach((prop) => {\n    Object.defineProperty(proto, prop, {\n      value: undefined,\n      configurable: true,\n    });\n  });\n\n  // defer properties to host\n  ['ownerDocument', 'baseURI', 'isConnected'].forEach((prop) => {\n    Object.defineProperty(proto, prop, {\n      /** @this {ShadowRoot} */\n      get() {\n        return this.host[prop];\n      },\n      configurable: true,\n    });\n  });\n};\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport * as utils from './utils.js';\n// prettier-ignore\nimport {eventPropertyNamesForElement, eventPropertyNamesForHTMLElement} from './patch-events.js';\n\n/** @implements {IWrapper} */\nclass Wrapper {\n  /** @param {!Node} node */\n  constructor(node) {\n    this.node = node;\n  }\n\n  // node\n  addEventListener(name, fn, options) {\n    return this.node[utils.SHADY_PREFIX + 'addEventListener'](\n      name,\n      fn,\n      options\n    );\n  }\n\n  removeEventListener(name, fn, options) {\n    return this.node[utils.SHADY_PREFIX + 'removeEventListener'](\n      name,\n      fn,\n      options\n    );\n  }\n\n  appendChild(node) {\n    return this.node[utils.SHADY_PREFIX + 'appendChild'](node);\n  }\n\n  insertBefore(node, ref_node) {\n    return this.node[utils.SHADY_PREFIX + 'insertBefore'](node, ref_node);\n  }\n\n  removeChild(node) {\n    return this.node[utils.SHADY_PREFIX + 'removeChild'](node);\n  }\n\n  replaceChild(node, ref_node) {\n    return this.node[utils.SHADY_PREFIX + 'replaceChild'](node, ref_node);\n  }\n\n  cloneNode(deep) {\n    return this.node[utils.SHADY_PREFIX + 'cloneNode'](deep);\n  }\n\n  getRootNode(options) {\n    return this.node[utils.SHADY_PREFIX + 'getRootNode'](options);\n  }\n\n  contains(node) {\n    return this.node[utils.SHADY_PREFIX + 'contains'](node);\n  }\n\n  dispatchEvent(event) {\n    return this.node[utils.SHADY_PREFIX + 'dispatchEvent'](event);\n  }\n\n  // element\n  setAttribute(name, value) {\n    this.node[utils.SHADY_PREFIX + 'setAttribute'](name, value);\n  }\n\n  // NOTE: not needed, just here for balance\n  getAttribute(name) {\n    return this.node[utils.NATIVE_PREFIX + 'getAttribute'](name);\n  }\n\n  // NOTE: not needed, just here for balance\n  hasAttribute(name) {\n    return this.node[utils.NATIVE_PREFIX + 'hasAttribute'](name);\n  }\n\n  removeAttribute(name) {\n    this.node[utils.SHADY_PREFIX + 'removeAttribute'](name);\n  }\n\n  attachShadow(options) {\n    return this.node[utils.SHADY_PREFIX + 'attachShadow'](options);\n  }\n\n  /** @return {!Node|undefined} */\n  get activeElement() {\n    if (\n      utils.isShadyRoot(this.node) ||\n      this.node.nodeType === Node.DOCUMENT_NODE\n    ) {\n      const e = this.node[utils.SHADY_PREFIX + 'activeElement'];\n      return e;\n    }\n    return undefined;\n  }\n\n  /**\n   * Installed for compatibility with browsers (older Chrome/Safari) that do\n   * not have a configurable `activeElement` accessor. Enables noPatch and\n   * patch mode both to consistently use ShadyDOM.wrap(document)._activeElement.\n   * @override\n   * @return {!Node|undefined}\n   */\n  get _activeElement() {\n    return this.activeElement;\n  }\n\n  // NOTE: not needed, just here for balance\n  /** @override */\n  focus() {\n    this.node[utils.NATIVE_PREFIX + 'focus']();\n  }\n\n  blur() {\n    this.node[utils.SHADY_PREFIX + 'blur']();\n  }\n\n  // document\n  importNode(node, deep) {\n    if (this.node.nodeType === Node.DOCUMENT_NODE) {\n      return this.node[utils.SHADY_PREFIX + 'importNode'](node, deep);\n    }\n  }\n\n  getElementById(id) {\n    if (this.node.nodeType === Node.DOCUMENT_NODE) {\n      return this.node[utils.SHADY_PREFIX + 'getElementById'](id);\n    }\n  }\n\n  elementsFromPoint(x, y) {\n    return this.node[utils.SHADY_PREFIX + 'elementsFromPoint'](x, y);\n  }\n\n  elementFromPoint(x, y) {\n    return this.node[utils.SHADY_PREFIX + 'elementFromPoint'](x, y);\n  }\n\n  // query\n  querySelector(selector) {\n    return this.node[utils.SHADY_PREFIX + 'querySelector'](selector);\n  }\n\n  querySelectorAll(selector, useNative) {\n    return this.node[utils.SHADY_PREFIX + 'querySelectorAll'](\n      selector,\n      useNative\n    );\n  }\n\n  // slot\n  assignedNodes(options) {\n    if (this.node.localName === 'slot') {\n      return this.node[utils.SHADY_PREFIX + 'assignedNodes'](options);\n    }\n  }\n\n  get host() {\n    if (utils.isShadyRoot(this.node)) {\n      return /** @type {!ShadowRoot} */ (this.node).host;\n    }\n    return undefined;\n  }\n\n  get parentNode() {\n    return this.node[utils.SHADY_PREFIX + 'parentNode'];\n  }\n\n  get firstChild() {\n    return this.node[utils.SHADY_PREFIX + 'firstChild'];\n  }\n\n  get lastChild() {\n    return this.node[utils.SHADY_PREFIX + 'lastChild'];\n  }\n\n  get nextSibling() {\n    return this.node[utils.SHADY_PREFIX + 'nextSibling'];\n  }\n\n  get previousSibling() {\n    return this.node[utils.SHADY_PREFIX + 'previousSibling'];\n  }\n\n  get childNodes() {\n    return this.node[utils.SHADY_PREFIX + 'childNodes'];\n  }\n\n  get parentElement() {\n    return this.node[utils.SHADY_PREFIX + 'parentElement'];\n  }\n\n  get firstElementChild() {\n    return this.node[utils.SHADY_PREFIX + 'firstElementChild'];\n  }\n\n  get lastElementChild() {\n    return this.node[utils.SHADY_PREFIX + 'lastElementChild'];\n  }\n\n  get nextElementSibling() {\n    return this.node[utils.SHADY_PREFIX + 'nextElementSibling'];\n  }\n\n  get previousElementSibling() {\n    return this.node[utils.SHADY_PREFIX + 'previousElementSibling'];\n  }\n\n  get children() {\n    return this.node[utils.SHADY_PREFIX + 'children'];\n  }\n\n  get childElementCount() {\n    return this.node[utils.SHADY_PREFIX + 'childElementCount'];\n  }\n\n  get shadowRoot() {\n    return this.node[utils.SHADY_PREFIX + 'shadowRoot'];\n  }\n\n  get assignedSlot() {\n    return this.node[utils.SHADY_PREFIX + 'assignedSlot'];\n  }\n\n  get isConnected() {\n    return this.node[utils.SHADY_PREFIX + 'isConnected'];\n  }\n\n  get innerHTML() {\n    return this.node[utils.SHADY_PREFIX + 'innerHTML'];\n  }\n\n  set innerHTML(value) {\n    this.node[utils.SHADY_PREFIX + 'innerHTML'] = value;\n  }\n\n  get textContent() {\n    return this.node[utils.SHADY_PREFIX + 'textContent'];\n  }\n\n  set textContent(value) {\n    this.node[utils.SHADY_PREFIX + 'textContent'] = value;\n  }\n\n  get slot() {\n    return this.node[utils.SHADY_PREFIX + 'slot'];\n  }\n\n  set slot(value) {\n    this.node[utils.SHADY_PREFIX + 'slot'] = value;\n  }\n\n  get className() {\n    return this.node[utils.SHADY_PREFIX + 'className'];\n  }\n\n  set className(value) {\n    this.node[utils.SHADY_PREFIX + 'className'] = value;\n  }\n\n  append(...args) {\n    return this.node[utils.SHADY_PREFIX + 'append'](...args);\n  }\n\n  prepend(...args) {\n    return this.node[utils.SHADY_PREFIX + 'prepend'](...args);\n  }\n\n  replaceChildren(...args) {\n    return this.node[utils.SHADY_PREFIX + 'replaceChildren'](...args);\n  }\n\n  after(...args) {\n    return this.node[utils.SHADY_PREFIX + 'after'](...args);\n  }\n\n  before(...args) {\n    return this.node[utils.SHADY_PREFIX + 'before'](...args);\n  }\n\n  remove() {\n    return this.node[utils.SHADY_PREFIX + 'remove']();\n  }\n\n  replaceWith(...args) {\n    return this.node[utils.SHADY_PREFIX + 'replaceWith'](...args);\n  }\n}\n\nconst addEventPropertyWrapper = (name) => {\n  Object.defineProperty(Wrapper.prototype, name, {\n    /** @this {Wrapper} */\n    get() {\n      return this.node[utils.SHADY_PREFIX + name];\n    },\n    /** @this {Wrapper} */\n    set(value) {\n      this.node[utils.SHADY_PREFIX + name] = value;\n    },\n    configurable: true,\n  });\n};\n\neventPropertyNamesForElement.forEach((name) => addEventPropertyWrapper(name));\neventPropertyNamesForHTMLElement.forEach((name) =>\n  addEventPropertyWrapper(name)\n);\n\nexport {Wrapper};\n\nconst wrapperMap = new WeakMap();\n\nexport function wrap(obj) {\n  if (utils.isShadyRoot(obj) || obj instanceof Wrapper) {\n    return obj;\n  }\n  let wrapper = wrapperMap.get(obj);\n  if (!wrapper) {\n    wrapper = new Wrapper(obj);\n    wrapperMap.set(obj, wrapper);\n  }\n  return wrapper;\n}\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\nimport * as utils from './utils.js';\nimport {flush, enqueue} from './flush.js';\n// prettier-ignore\nimport {observeChildren, unobserveChildren, filterMutations} from './observe-changes.js';\n// prettier-ignore\nimport {addNativePrefixedProperties, nativeMethods, nativeTree} from './patch-native.js';\n// prettier-ignore\nimport {patchInsideElementAccessors, patchOutsideElementAccessors} from './patch-instances.js';\nimport {patchEvents, patchClick, composedPath} from './patch-events.js';\nimport {ShadyRoot} from './attach-shadow.js';\nimport {wrap, Wrapper} from './wrapper.js';\n// prettier-ignore\nimport {addShadyPrefixedProperties, applyPatches, patchShadowOnElement, patchElementProto} from './patch-prototypes.js';\n\nif (utils.settings.inUse) {\n  const patch = utils.settings.hasDescriptors\n    ? (n) => n\n    : (node) => {\n        patchInsideElementAccessors(node);\n        patchOutsideElementAccessors(node);\n        return node;\n      };\n\n  let ShadyDOM = {\n    // TODO(sorvell): remove when Polymer does not depend on this.\n    'inUse': utils.settings.inUse,\n    // NOTE: old browsers without prototype accessors (very old Chrome\n    // and Safari) need manually patched accessors to properly set\n    // `innerHTML` and `textContent` when an element is:\n    // (1) inside a shadowRoot\n    // (2) does not have special (slot) children itself\n    // (3) and setting the property needs to provoke distribution (because\n    // a nested slot is added/removed)\n    'patch': patch,\n    'isShadyRoot': utils.isShadyRoot,\n    'enqueue': enqueue,\n    'flush': flush,\n    'flushInitial': (root) => {\n      root._flushInitial();\n    },\n    'settings': utils.settings,\n    'filterMutations': filterMutations,\n    'observeChildren': observeChildren,\n    'unobserveChildren': unobserveChildren,\n    // Set to true to defer native custom elements connection until the\n    // document has fully parsed. This enables custom elements that create\n    // shadowRoots to be defined while the document is loading. Elements\n    // customized as they are created by the parser will successfully\n    // render with this flag on.\n    'deferConnectionCallbacks': utils.settings['deferConnectionCallbacks'],\n    // Set to true to speed up the polyfill slightly at the cost of correctness\n    // * does not patch querySelector/All on Document or DocumentFragment\n    // * does not wrap connected/disconnected callbacks to de-dup these\n    // when using native customElements\n    // * does not wait to process children of elements with shadowRoots\n    // meaning shadowRoots should not be created while an element is parsing\n    // (e.g. if a custom element that creates a shadowRoot is defined before\n    // a candidate element in the document below it.\n    'preferPerformance': utils.settings['preferPerformance'],\n    // Integration point with ShadyCSS to disable styling MutationObserver,\n    // as ShadyDOM will now handle dynamic scoping.\n    'handlesDynamicScoping': true,\n    // Ensure the node is wrapped. This should be used when `noPatch` is set\n    // to ensure Shadow DOM compatible DOM operation.\n    // Note, wrap falls back to patch so that it ensures API \"always just works\"\n    'wrap': utils.settings.noPatch ? wrap : patch,\n    // When code should be compatible with `noPatch` `true` and `on-demand`\n    // settings, `wrapIfNeeded` can be used for optimal performance (v. `wrap`)\n    // for all DOM operations except the following: `appendChild` and\n    // `insertBefore` (when the node is being moved from a location where it\n    // was logically positioned in the DOM); when setting `className`/`class`;\n    // when calling `querySelector|All`; when setting `textContent` or\n    // `innerHTML`; `addEventListener`, `removeEventListener` and\n    // `dispatchEvent`; and all scope specific API's like `getRootNode`,\n    // `isConnected`, `slot`, `assignedSlot`, `assignedNodes`. Note,\n    // `wrapIfNeeded` falls back to a pass through to preserve optimal\n    // performance.\n    'wrapIfNeeded': utils.settings.noPatch === true ? wrap : (n) => n,\n    'Wrapper': Wrapper,\n    'composedPath': composedPath,\n    // Set to true to avoid patching regular platform property names. When set,\n    // Shadow DOM compatible behavior is only available when accessing DOM\n    // API using `ShadyDOM.wrap`, e.g. `ShadyDOM.wrap(element).shadowRoot`.\n    // This setting provides a small performance boost, but requires all DOM API\n    // access that requires Shadow DOM behavior to be proxied via `ShadyDOM.wrap`.\n    //\n    // WARNING: When `noPatch` is set and the Custom Elements polyfill is\n    // needed, the Custom Elements polyfill must be loaded before this\n    // polyfill; however, when `noPatch` is not used, this polyfill should be\n    // loaded before the Custom Elements polyfill. This is because\n    // ShadyDOM captures DOM mutation methods and when `noPatch` is used,\n    // ShadyDOM must call the mutation methods patched by the Custom Elements\n    // polyfill or custom elements will not function as expected. When `noPatch`\n    // is not used, the Custom Elements polyfill patches call through to the\n    // ShadyDOM patches so ShadyDOM should be loaded first.\n    'noPatch': utils.settings.noPatch,\n    'patchOnDemand': utils.settings.patchOnDemand,\n    'nativeMethods': nativeMethods,\n    'nativeTree': nativeTree,\n    'patchElementProto': patchElementProto,\n  };\n\n  window['ShadyDOM'] = ShadyDOM;\n\n  // Modifies native prototypes for Node, Element, etc. to\n  // make native platform behavior available at prefixed names, e.g.\n  // `utils.NATIVE_PREFIX + 'firstChild'` or `__shady_native_firstChild`.\n  // This allows the standard names to be safely patched while retaining the\n  // ability for native behavior to be used. This polyfill manipulates DOM\n  // by using this saved native behavior.\n  // Note, some browsers do not have proper element descriptors for\n  // accessors; in this case, native behavior for these accessors is simulated\n  // via a TreeWalker.\n  addNativePrefixedProperties();\n\n  // Modifies native prototypes for Node, Element, etc. to make ShadowDOM\n  // behavior available at prefixed names, e.g.\n  // `utils.SHADY_PREFIX + 'firstChild` or `__shady_firstChild`. This is done\n  // so this polyfill can perform Shadow DOM style DOM manipulation.\n  // Because patching normal platform property names is optional, these prefixed\n  // names are used internally.\n  addShadyPrefixedProperties();\n\n  // Modifies native prototypes for Node, Element, etc. to patch\n  // regular platform property names to have Shadow DOM compatible API behavior.\n  // This applies the utils.SHADY_PREFIX behavior to normal names. For example,\n  // if `noPatch` is not set, then `el.__shady_firstChild` is equivalent to\n  // `el.firstChild`.\n  // NOTE, on older browsers (old Chrome/Safari) native accessors cannot be\n  // patched on prototypes (e.g. Node.prototype.firstChild cannot be modified).\n  // On these browsers, instance level patching is performed where needed; this\n  // instance patching is only done when `noPatch` is *not* set.\n  if (!utils.settings.noPatch) {\n    applyPatches();\n    // Patch click event behavior only if we're patching\n    patchClick();\n  } else if (utils.settings.patchOnDemand) {\n    // In `on-demand` patching, do patch `attachShadow` and `shadowRoot`.\n    // These are the only patched properties in `on-demand` mode and these\n    // patches kick off patching \"on-demand\" for other nodes.\n    patchShadowOnElement();\n  }\n\n  // For simplicity, patch events unconditionally.\n  // Patches the event system to have Shadow DOM compatible behavior (e.g.\n  // event retargeting). When `noPatch` is set, retargeting is only available\n  // when adding event listeners and dispatching events via `ShadyDOM.wrap`\n  // (e.g. `ShadyDOM.wrap(element).addEventListener(...)`).\n  patchEvents();\n\n  window.ShadowRoot = /** @type {function(new:ShadowRoot)} */ (ShadyRoot);\n}\n"]},"metadata":{},"sourceType":"script"}